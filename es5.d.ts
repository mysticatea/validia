// Generated by dts-bundle-generator v5.6.0

/**
 * All schemas.
 */
export declare type Schema = Schema.Any | Schema.Array<Schema> | Schema.BigInt | Schema.Boolean | Schema.Class<any> | Schema.Custom<any> | Schema.Enum<any> | Schema.Function | Schema.Number | Schema.Object<Record<string, Schema>, any, boolean> | Schema.Record<Schema> | Schema.String | Schema.Symbol | Schema.Tuple<readonly Schema[]> | Schema.Union<Schema>;
export declare namespace Schema {
	/**
	 * The schema that allows any values.
	 */
	interface Any {
		/** The schema type. */
		readonly type: "any";
	}
	/**
	 * The schema for arrays.
	 */
	interface Array<T extends Schema> {
		/** The schema type. */
		readonly type: "array";
		/** The schema of elements. */
		readonly elements: T;
		/** The maximum length. */
		readonly maxLength?: number;
		/** The minimum length. */
		readonly minLength?: number;
		/** The flag to disallow duplicated values. */
		readonly unique?: boolean;
	}
	/**
	 * The schema for bigint values.
	 */
	interface BigInt {
		/** The schema type. */
		readonly type: "bigint";
		/** The maximum value. */
		readonly maxValue?: bigint;
		/** The minimum value. */
		readonly minValue?: bigint;
	}
	/**
	 * The schema for arrays.
	 */
	interface Boolean {
		/** The schema type. */
		readonly type: "boolean";
	}
	/**
	 * The schema for class instances.
	 */
	interface Class<T> {
		/** The schema type. */
		readonly type: "class";
		/** The constructor of allowed instances. */
		readonly constructor: {
			new (...args: any[]): T;
			prototype: T;
			name: string;
		};
	}
	/**
	 * The schema for user-defined checks.
	 */
	interface Custom<T> {
		/** The schema type. */
		readonly type: "custom";
		/** The name to show in error messages. */
		readonly name: string;
		/** The check logic. */
		readonly check: (x: unknown) => x is T;
	}
	/**
	 * The schema for any of listed values.
	 */
	interface Enum<T> {
		/** The schema type. */
		readonly type: "enum";
		/** The allowed values. */
		readonly values: readonly T[];
	}
	/**
	 * The schema for functions.
	 */
	interface Function {
		/** The schema type. */
		readonly type: "function";
	}
	/**
	 * The schema for numbers.
	 */
	interface Number {
		/** The schema type. */
		readonly type: "number";
		/** The flag to allow `Infinity` and `-Infinity`. Infinities are disallowed by default. */
		readonly allowInfinity?: boolean;
		/** The flag to allow `NaN`. `NaN` is disallowed by default. */
		readonly allowNaN?: boolean;
		/** The flag to disallow non-integer values. */
		readonly intOnly?: boolean;
		/** The maximum value. */
		readonly maxValue?: number;
		/** The minimum value. */
		readonly minValue?: number;
	}
	/**
	 * The schema for plain objects.
	 */
	interface Object<TProperties extends globalThis.Record<string | number, Schema>, TRequired extends keyof TProperties, TAllowUnknown extends boolean> {
		/** The schema type. */
		readonly type: "object";
		/** The flag to allow unknown properties. */
		readonly allowUnknown?: TAllowUnknown;
		/** The schema of known properties. */
		readonly properties: TProperties;
		/** The name of required properties. */
		readonly required?: readonly TRequired[];
	}
	/**
	 * The schema for record objects.
	 */
	interface Record<T extends Schema> {
		/** The schema type. */
		readonly type: "record";
		/** The schema of known properties. */
		readonly properties: T;
	}
	/**
	 * The schema for strings.
	 */
	interface String {
		/** The schema type. */
		readonly type: "string";
		/** The maximum length. */
		readonly maxLength?: number;
		/** The minimum length. */
		readonly minLength?: number;
		/** The allowed pattern. */
		readonly pattern?: globalThis.RegExp;
	}
	/**
	 * The schema for symbols.
	 */
	interface Symbol {
		/** The schema type. */
		readonly type: "symbol";
	}
	/**
	 * The schema for tuples.
	 */
	interface Tuple<T extends readonly Schema[]> {
		/** The schema type. */
		readonly type: "tuple";
		/** The schema of elements */
		readonly elements: T;
	}
	/**
	 * The schema for satisfying any of listed schemas.
	 */
	interface Union<T extends Schema> {
		/** The schema type. */
		readonly type: "union";
		/** The schemas of allowed values. */
		readonly schemas: readonly T[];
	}
}
/**
 * The message generator.
 *
 * You can implement this interface to generate your own error messages.
 *
 * The default implementation is {@link DefaultMessage}.
 */
export interface Message {
	/**
	 * Get the error message that a value is expected to be an array but wasn't.
	 * @param args The arguments of this error.
	 */
	array(args: {
		name: string;
	}): string;
	/**
	 * Get the error message that the length of arrays was greater than the maximum value.
	 * @param args The arguments of this error.
	 */
	arrayMaxLength(args: {
		name: string;
		maxLength: number;
	}): string;
	/**
	 * Get the error message that the length of arrays was less than the minimum value.
	 * @param args The arguments of this error.
	 */
	arrayMinLength(args: {
		name: string;
		minLength: number;
	}): string;
	/**
	 * Get the error message that an array is expected to not contain duplicated values but wasn't.
	 * @param args The arguments of this error.
	 */
	arrayUnique(args: {
		name: string;
	}): string;
	/**
	 * Get the error message that a value is expected to be a bigint value but wasn't.
	 * @param args The arguments of this error.
	 */
	bigint(args: {
		name: string;
	}): string;
	/**
	 * Get the error message that a bigint value was greater than the maximum value.
	 * @param args The arguments of this error.
	 */
	bigintMaxValue(args: {
		name: string;
		maxValue: bigint;
	}): string;
	/**
	 * Get the error message that a bigint value was less than the minimum value.
	 * @param args The arguments of this error.
	 */
	bigintMinValue(args: {
		name: string;
		minValue: bigint;
	}): string;
	/**
	 * Get the error message that a value is expected to be a boolean value but wasn't.
	 * @param args The arguments of this error.
	 */
	boolean(args: {
		name: string;
	}): string;
	/**
	 * Get the error message that a value is expected to be an instance of a specific class but wasn't.
	 * @param args The arguments of this error.
	 */
	class(args: {
		name: string;
		constructor: Function;
	}): string;
	/**
	 * Get the error message that a value failed a specific user-defined check.
	 * @param args The arguments of this error.
	 */
	custom(args: {
		name: string;
		checkFunc: Function;
		checkName: string;
	}): string;
	/**
	 * Get the error message that a value is expected to be any of the specific values but wasn't.
	 * @param args The arguments of this error.
	 */
	enum(args: {
		name: string;
		values: readonly any[];
	}): string;
	/**
	 * Get the error message that a value is expected to be a function but wasn't.
	 * @param args The arguments of this error.
	 */
	function(args: {
		name: string;
	}): string;
	/**
	 * Get the error message that a value is expected to be a number but wasn't.
	 * @param args The arguments of this error.
	 */
	number(args: {
		name: string;
	}): string;
	/**
	 * Get the error message that a value was unexpected infinity.
	 * @param args The arguments of this error.
	 */
	numberDisallowInfinity(args: {
		name: string;
	}): string;
	/**
	 * Get the error message that a value was unexpected `NaN`.
	 * @param args The arguments of this error.
	 */
	numberDisallowNaN(args: {
		name: string;
	}): string;
	/**
	 * Get the error message that a value is expected to be an integer but wasn't.
	 * @param args The arguments of this error.
	 */
	numberIntOnly(args: {
		name: string;
	}): string;
	/**
	 * Get the error message that a number was greater than the maximum value.
	 * @param args The arguments of this error.
	 */
	numberMaxValue(args: {
		name: string;
		maxValue: number;
	}): string;
	/**
	 * Get the error message that a number was less than the minimum value.
	 * @param args The arguments of this error.
	 */
	numberMinValue(args: {
		name: string;
		minValue: number;
	}): string;
	/**
	 * Get the error message that a value is expected to be an object instance but wasn't.
	 * @param args The arguments of this error.
	 */
	object(args: {
		name: string;
	}): string;
	/**
	 * Get the error message that an object instance was lacking the required properties.
	 * @param args The arguments of this error.
	 */
	objectRequiredKeys(args: {
		name: string;
		keys: readonly string[];
	}): string;
	/**
	 * Get the error message that an object instance was having extra properties.
	 * @param args The arguments of this error.
	 */
	objectUnknownKeys(args: {
		name: string;
		keys: readonly string[];
	}): string;
	/**
	 * Get the error message that a value is expected to be a string but wasn't.
	 * @param args The arguments of this error.
	 */
	string(args: {
		name: string;
	}): string;
	/**
	 * Get the error message that the length of strings was greater than the maximum value.
	 * @param args The arguments of this error.
	 */
	stringMaxLength(args: {
		name: string;
		maxLength: number;
	}): string;
	/**
	 * Get the error message that the length of strings was less than the minimum value.
	 * @param args The arguments of this error.
	 */
	stringMinLength(args: {
		name: string;
		minLength: number;
	}): string;
	/**
	 * Get the error message that a string didn't match with a specific pattern.
	 * @param args The arguments of this error.
	 */
	stringPattern(args: {
		name: string;
		pattern: RegExp;
	}): string;
	/**
	 * Get the error message that a value is expected to be a symbol but wasn't.
	 * @param args The arguments of this error.
	 */
	symbol(args: {
		name: string;
	}): string;
	/**
	 * Get the error message that a value is expected to be a tuple instance but wasn't.
	 * @param args The arguments of this error.
	 */
	tuple(args: {
		name: string;
	}): string;
	/**
	 * Get the error message that the length of tuples didn't match.
	 * @param args The arguments of this error.
	 */
	tupleLength(args: {
		name: string;
		length: number;
	}): string;
	/**
	 * Get the error message that a value is expected to be any of the specific values but wasn't.
	 * @param args The arguments of this error.
	 */
	union(args: {
		name: string;
		schemas: readonly Exclude<Schema, Schema.Any | Schema.Union<any>>[];
	}): string;
	/**
	 * Get the error message that a value had one or more validation errors.
	 * @param args The arguments of this error.
	 */
	validation(args: {
		name: string;
		errors: readonly string[];
	}): string;
}
/**
 * The default error message generator.
 */
export declare const DefaultMessage: Message;
/**
 * The type function to derive the type of schemas.
 */
export declare type TypeOf<T extends Schema> = TypeOf.AnySchema<T> | TypeOf.ArraySchema<T> | TypeOf.BigIntSchema<T> | TypeOf.BooleanSchema<T> | TypeOf.ClassSchema<T> | TypeOf.CustomSchema<T> | TypeOf.EnumSchema<T> | TypeOf.FunctionSchema<T> | TypeOf.NumberSchema<T> | TypeOf.ObjectSchema<T> | TypeOf.RecordSchema<T> | TypeOf.StringSchema<T> | TypeOf.SymbolSchema<T> | TypeOf.TupleSchema<T> | TypeOf.UnionSchema<T>;
export declare namespace TypeOf {
	/**
	 * The type function to derive the type of schemas.
	 */
	type AnySchema<T extends Schema> = T extends Schema.Any ? any : never;
	/**
	 * The type function to derive the type of schemas.
	 */
	type ArraySchema<T extends Schema> = T extends Schema.Array<infer U> ? TypeOf<U>[] : never;
	/**
	 * The type function to derive the type of schemas.
	 */
	type BigIntSchema<T extends Schema> = T extends Schema.BigInt ? bigint : never;
	/**
	 * The type function to derive the type of schemas.
	 */
	type BooleanSchema<T extends Schema> = T extends Schema.Boolean ? boolean : never;
	/**
	 * The type function to derive the type of schemas.
	 */
	type ClassSchema<T extends Schema> = T extends Schema.Class<infer U> ? U : never;
	/**
	 * The type function to derive the type of schemas.
	 */
	type CustomSchema<T extends Schema> = T extends Schema.Custom<infer U> ? U : never;
	/**
	 * The type function to derive the type of schemas.
	 */
	type EnumSchema<T extends Schema> = T extends Schema.Enum<infer U> ? U : never;
	/**
	 * The type function to derive the type of schemas.
	 */
	type FunctionSchema<T extends Schema> = T extends Schema.Function ? (...args: any[]) => any : never;
	/**
	 * The type function to derive the type of schemas.
	 */
	type NumberSchema<T extends Schema> = T extends Schema.Number ? number : never;
	/**
	 * The type function to derive the type of schemas.
	 */
	type ObjectSchema<T extends Schema> = T extends Schema.Object<infer P, infer R, infer A> ? ObjectSchema.Flatten<ObjectSchema.KnownProperties<P, R> & ObjectSchema.UnknownProperties<A>> : never;
	namespace ObjectSchema {
		type KnownProperties<P extends Record<string | number, Schema>, R extends keyof P> = {
			[K in Extract<keyof P, R>]: TypeOf<P[K]>;
		} & {
			[K in Exclude<keyof P, R>]?: TypeOf<P[K]> | undefined;
		};
		type UnknownProperties<A extends boolean> = A extends true ? Record<string | number, unknown> : {};
		type Flatten<T> = T extends any ? {
			[P in keyof T]: T[P];
		} : never;
	}
	/**
	 * The type function to derive the type of schemas.
	 */
	type RecordSchema<T extends Schema> = T extends Schema.Record<infer U> ? Record<number | string | symbol, TypeOf<U>> : never;
	/**
	 * The type function to derive the type of schemas.
	 */
	type StringSchema<T extends Schema> = T extends Schema.String ? string : never;
	/**
	 * The type function to derive the type of schemas.
	 */
	type SymbolSchema<T extends Schema> = T extends Schema.Symbol ? symbol : never;
	/**
	 * The type function to derive the type of schemas.
	 */
	type TupleSchema<T extends Schema> = T extends Schema.Tuple<infer U> ? U extends readonly any[] ? {
		[P in keyof U]: TypeOf<U[P]>;
	} : never : never;
	/**
	 * The type function to derive the type of schemas.
	 */
	type UnionSchema<T extends Schema> = T extends Schema.Union<infer U> ? TypeOf<U> : never;
}
/**
 * The type of validation functions.
 *
 * The validation function has two parameters.
 * - `value` ... The value to validate.
 * - `options` ... Optional. The options.
 *
 * If the `value` passed the validation, the `value` gets the specific type that
 * is computed from the schema `T`. Otherwise, the validation function throws a
 * validation error.
 */
export declare type Validate<T extends Schema> = (value: any, options?: Validate.Options) => asserts value is TypeOf<T>;
export declare namespace Validate {
	/**
	 * The options of validation functions.
	 */
	type Options = {
		/**
		 * The error message generator.
		 */
		messages?: Message;
		/**
		 * The name of the target value.
		 * This will be used in error messages.
		 */
		name?: string;
	};
}
/**
 * Compile the validation function of a schema object.
 *
 * Once compiled, it validates values efficiently.
 *
 * The validation code is cached for each schema object into a `WeakMap` object.
 * When GC collected the schema object, the validation code of that is abandoned
 * together.
 *
 * @param schema The schema of the validation.
 * @param options The options.
 * @returns The validation function of the schema.
 */
export declare function createValidation<T extends Schema>(schema: T, { defaultMessages }?: createValidation.Options): Validate<T>;
export declare namespace createValidation {
	/**
	 * The options of validation function compilation.
	 */
	type Options = {
		/**
		 * The error message generator.
		 */
		defaultMessages?: Message;
	};
}
declare class SchemaFactories {
	/**
	 * The schema for any values.
	 */
	any(): Schema.Any;
	/**
	 * The schema for array instances.
	 * @param elements The schema of element types.
	 * @param options The options.
	 */
	array(): Schema.Array<Schema.Any>;
	/**
	 * The schema for array instances.
	 * @param elements The schema of element types.
	 * @param options The options.
	 */
	array<T extends Schema>(elements: T, options?: Omit<Schema.Array<T>, "type" | "elements">): Schema.Array<T>;
	/**
	 * The schema for bigint values.
	 * @param options The options.
	 */
	bigInt({ maxValue, minValue, }?: Omit<Schema.BigInt, "type">): Schema.BigInt;
	/**
	 * The schema for 64 bits signed integers.
	 */
	bigInt64: Schema.BigInt;
	/**
	 * The schema for 64 bits unsigned integers.
	 */
	bigUint64: Schema.BigInt;
	/**
	 * The schema for true or false.
	 */
	boolean(): Schema.Boolean;
	/**
	 * The schema for specific class instances.
	 * @param constructor The constructor to use `instanceof` operations.
	 */
	instanceOf<T>(constructor: Schema.Class<T>["constructor"]): Schema.Class<T>;
	/**
	 * The schema for user-defined checks.
	 * @param name The name of the valid values. This name will be shown in error messages.
	 * @param check The check.
	 */
	custom<T>(name: string, check: (x: any) => x is T): Schema.Custom<T>;
	/**
	 * The schema for any of listed values.
	 * @param firstValue One of allowed values.
	 * @param restValues Rest of allowed values.
	 */
	enum<T, U extends readonly any[]>(firstValue: T, ...restValues: U): Schema.Enum<T | U[number]>;
	/**
	 * The schema for null.
	 * Equivalent to `schemas.enum(null)`.
	 */
	null: Schema.Enum<null>;
	/**
	 * The schema for any functions.
	 */
	function(): Schema.Function;
	/**
	 * The schema for numbers.
	 * @param options The options.
	 */
	number({ allowInfinity, allowNaN, intOnly, maxValue, minValue, }?: Omit<Schema.Number, "type">): Schema.Number;
	/**
	 * The schema for 8 bits signed integers.
	 */
	int8: Schema.Number;
	/**
	 * The schema for 16 bits signed integers.
	 */
	int16: Schema.Number;
	/**
	 * The schema for 32 bits signed integers.
	 */
	int32: Schema.Number;
	/**
	 * The schema for 8 bits unsigned integers.
	 */
	uint8: Schema.Number;
	/**
	 * The schema for 16 bits unsigned integers.
	 */
	uint16: Schema.Number;
	/**
	 * The schema for 32 bits unsigned integers.
	 */
	uint32: Schema.Number;
	/**
	 * The schema for any objects.
	 */
	object(): Schema.Object<{}, never, true>;
	/**
	 * The schema for plain objects. All known properties are optional.
	 * @param properties The schema of known properties.
	 */
	object<TProperties extends Record<string | number, Schema>>(properties: TProperties): Schema.Object<TProperties, never, false>;
	/**
	 * The schema for plain objects. All known properties are optional.
	 * @param properties The schema of known properties.
	 * @param options The options.
	 */
	object<TProperties extends Record<string | number, Schema>>(properties: TProperties, options: Record<string | number | symbol, never>): Schema.Object<TProperties, never, false>;
	/**
	 * The schema for plain objects. All known properties are optional.
	 * @param properties The schema of known properties.
	 * @param options The options.
	 */
	object<TProperties extends Record<string | number, Schema>, TAllowUnknown extends boolean>(properties: TProperties, options: {
		allowUnknown: TAllowUnknown;
	}): Schema.Object<TProperties, never, TAllowUnknown>;
	/**
	 * The schema for plain objects. All known properties are required.
	 * @param properties The schema of known properties.
	 * @param options The options.
	 */
	object<TProperties extends Record<string | number, Schema>>(properties: TProperties, options: {
		required: true;
	}): Schema.Object<TProperties, keyof TProperties, false>;
	/**
	 * The schema for plain objects. Specified known properties are required.
	 * @param properties The schema of known properties.
	 * @param options The options.
	 */
	object<TProperties extends Record<string | number, Schema>, TRequired extends keyof TProperties>(properties: TProperties, options: {
		required: readonly TRequired[];
	}): Schema.Object<TProperties, TRequired, false>;
	/**
	 * The schema for plain objects. All known properties are required.
	 * @param properties The schema of known properties.
	 * @param options The options.
	 */
	object<TProperties extends Record<string | number, Schema>, TAllowUnknown extends boolean>(properties: TProperties, options: {
		allowUnknown: TAllowUnknown;
		required: true;
	}): Schema.Object<TProperties, keyof TProperties, TAllowUnknown>;
	/**
	 * The schema for plain objects. Specific properties are required.
	 * @param properties The schema of known properties.
	 * @param options The options.
	 */
	object<TProperties extends Record<string | number, Schema>, TRequired extends keyof TProperties, TAllowUnknown extends boolean>(properties: TProperties, options: {
		allowUnknown: TAllowUnknown;
		required: readonly TRequired[];
	}): Schema.Object<TProperties, TRequired, TAllowUnknown>;
	/**
	 * The schema for any objects.
	 */
	record(): Schema.Record<Schema.Any>;
	/**
	 * The schema for plain objects.
	 * @param properties The schema of properties.
	 */
	record<T extends Schema>(properties: T): Schema.Record<T>;
	/**
	 * The schema for strings.
	 * @param options The options.
	 */
	string({ maxLength, minLength, pattern, }?: Omit<Schema.String, "type">): Schema.String;
	/**
	 * The schema for any symbols.
	 */
	symbol(): Schema.Symbol;
	/**
	 * The schema for tuples.
	 * @param elements The schema of elements.
	 */
	tuple<T extends readonly Schema[]>(...elements: T): Schema.Tuple<T>;
	/**
	 * The schema for any of listed schemas.
	 * @param firstSchema One of allowed schemas.
	 * @param restSchemas Rest of allowed schemas.
	 */
	anyOf<T extends Schema, U extends readonly Schema[]>(firstSchema: T, ...restSchemas: U): Schema.Union<T | U[number]>;
}
/**
 * The schema factories.
 */
export declare const schemas: Readonly<SchemaFactories>;
/**
 * Validate a value by a given schema.
 *
 * If the `value` passed the validation, the `value` gets the specific type that
 * is computed from the schema type `T`. Otherwise, the validation function
 * throws a validation error.
 *
 * The validation code is cached for each schema object into a `WeakMap` object.
 * When GC collected the schema object, the validation code of that is abandoned
 * together.
 *
 * The {@link createValidation} function creates the validation function of
 * schemas to validate values efficiently. Consider using that if you planned to
 * validate values many times.
 *
 * @param schema The schema of the validation.
 * @param value The value to validate.
 * @param options Optional. The options.
 * @throws {@link ValidationError} Thrown if the `value` didn't pass the
 * validation.
 */
export declare function validate<T extends Schema>(schema: T, value: any, { messages, name }?: validate.Options): asserts value is TypeOf<T>;
export declare namespace validate {
	/**
	 * The options of validation.
	 */
	type Options = {
		/**
		 * The error message generator.
		 */
		messages?: Message;
		/**
		 * The name of the target value.
		 * This will be used in error messages.
		 */
		name?: string;
	};
}
/**
 * Validation errors.
 */
export declare class ValidationError extends Error {
	/**
	 * The errors.
	 * Every error has `code` and `args`.
	 */
	readonly errors: readonly ValidationError.ErrorInfo[];
	/**
	 * Initialize this instance.
	 * @param message The message generator.
	 * @param name The target name.
	 * @param errors The errors.
	 */
	constructor(message: Message, name: string, errors: ValidationError.ErrorInfo[]);
}
export declare namespace ValidationError {
	/**
	 * The error code.
	 */
	type ErrorCode = Exclude<keyof Message, "validation">;
	/**
	 * The pair of a error code and arguments.
	 */
	type ErrorInfo = {
		[P in ErrorCode]: {
			code: P;
			args: Parameters<Message[P]>[0];
			depth: number;
		};
	}[ErrorCode];
}

export {};
