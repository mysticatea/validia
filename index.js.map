{"version":3,"file":"index.js","sources":["src/constants.ts","src/builder/array-schema.ts","src/builder/bigint-schema.ts","src/builder/boolean-schema.ts","src/builder/class-schema.ts","src/builder/context.ts","src/builder/custom-schema.ts","src/builder/enum-schema.ts","src/builder/function-schema.ts","src/builder/number-schema.ts","src/builder/object-schema.ts","src/builder/record-schema.ts","src/builder/string-schema.ts","src/builder/symbol-schema.ts","src/builder/tuple-schema.ts","src/builder/union-schema.ts","src/builder/schema.ts","src/message/default-message.ts","src/validation-error.ts","src/create-validate.ts","src/cache.ts","src/schema-factories.ts","src/validate.ts"],"sourcesContent":["export const MaxInt8 = 127\nexport const MaxInt16 = 32767\nexport const MaxInt32 = 2147483647\nexport const MaxInt64 = BigInt(\"9223372036854775807\")\nexport const MaxUint8 = 255\nexport const MaxUint16 = 65535\nexport const MaxUint32 = 4294967295\nexport const MaxUint64 = BigInt(\"18446744073709551615\")\nexport const MinInt8 = -128\nexport const MinInt16 = -32768\nexport const MinInt32 = -2147483648\nexport const MinInt64 = BigInt(\"9223372036854775807\")\nexport const MaxArrayLength = MaxUint32\nexport const MaxStringLength = 9007199254740991\n","import { MaxArrayLength } from \"../constants\"\nimport { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\nimport { addValidationCodeOfSchema } from \"./schema\"\n\nexport function addValidationCodeOfArraySchema(\n    ctx: BuildContext,\n    {\n        elements,\n        maxLength = MaxArrayLength,\n        minLength = 0,\n        unique = false,\n    }: Schema.ArraySchema<Schema>,\n    nameVar: string,\n    valueVar: string,\n): void {\n    ctx.addCodeFragment(`\n        if (!Array.isArray(${valueVar})) {\n            errors.push({ code: \"array\", args: { name: ${nameVar} }, depth: ${ctx.depth} });\n    `)\n\n    if (\n        elements.type === \"any\" &&\n        maxLength >= MaxArrayLength &&\n        minLength <= 0 &&\n        !unique\n    ) {\n        ctx.addCodeFragment(\"}\")\n        return\n    }\n    ctx.addCodeFragment(\"} else {\")\n\n    const lengthVar = ctx.addLocal(\"i\")\n    ctx.addCodeFragment(`${lengthVar} = ${valueVar}.length;`)\n\n    if (maxLength < MaxArrayLength) {\n        ctx.addCodeFragment(`\n            if (${lengthVar} > ${maxLength}) {\n                errors.push({ code: \"arrayMaxLength\", args: { name: ${nameVar}, maxLength: ${maxLength} }, depth: ${ctx.depth} });\n            }\n        `)\n    }\n    if (minLength > 0) {\n        ctx.addCodeFragment(`\n            if (${lengthVar} < ${minLength}) {\n                errors.push({ code: \"arrayMinLength\", args: { name: ${nameVar}, minLength: ${minLength} }, depth: ${ctx.depth} });\n            }\n        `)\n    }\n    if (unique) {\n        const isUniqueVar = ctx.addArgument(isUnique)\n        ctx.addCodeFragment(`\n            if (!${isUniqueVar}(${valueVar}, ${lengthVar})) {\n                errors.push({ code: \"arrayUnique\", args: { name: ${nameVar} }, depth: ${ctx.depth} });\n            }\n        `)\n    }\n    if (elements.type !== \"any\") {\n        const iVar = ctx.addLocal(\"i\")\n        ctx.stackLocalScope()\n        const elementNameVar = ctx.addLocal(\"s\")\n        const elementValueVar = ctx.addLocal(\"r\")\n        ctx.addCodeFragment(`\n            for (${iVar} = 0; ${iVar} < ${lengthVar}; ++${iVar}) {\n                ${elementNameVar} = ${nameVar} + \"[\" + ${iVar} + \"]\";\n                ${elementValueVar} = ${valueVar}[${iVar}];\n        `)\n        addValidationCodeOfSchema(\n            ctx,\n            elements,\n            elementNameVar,\n            elementValueVar,\n        )\n        ctx.popLocalScope()\n        ctx.addCodeFragment(\"}\")\n    }\n\n    ctx.addCodeFragment(\"}\")\n}\n\nfunction isUnique(xs: any[], length: number): boolean {\n    for (let i = 1; i < length; ++i) {\n        const x = xs[i]\n        for (let j = 0; j < i; ++j) {\n            if (x === xs[j]) {\n                return false\n            }\n        }\n    }\n    return true\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationCodeOfBigIntSchema(\n    ctx: BuildContext,\n    { maxValue, minValue }: Schema.BigIntSchema,\n    nameVar: string,\n    valueVar: string,\n): void {\n    ctx.addCodeFragment(`\n        if (typeof ${valueVar} !== \"bigint\") {\n            errors.push({ code: \"bigint\", args: { name: ${nameVar} }, depth: ${ctx.depth} });\n    `)\n    if (maxValue == null && minValue == null) {\n        ctx.addCodeFragment(\"}\")\n        return\n    }\n    ctx.addCodeFragment(\"} else {\")\n\n    if (maxValue != null) {\n        if (minValue != null && minValue > maxValue) {\n            throw new Error('\"maxValue\" must be \"minValue\" or greater than it.')\n        }\n        ctx.addCodeFragment(`\n            if (${valueVar} > ${maxValue}n) {\n                errors.push({ code: \"bigintMaxValue\", args: { name: ${nameVar}, maxValue: ${maxValue}n }, depth: ${ctx.depth} });\n            }\n        `)\n    }\n    if (minValue != null) {\n        ctx.addCodeFragment(`\n            if (${valueVar} < ${minValue}n) {\n                errors.push({ code: \"bigintMinValue\", args: { name: ${nameVar}, minValue: ${minValue}n }, depth: ${ctx.depth} });\n            }\n        `)\n    }\n\n    ctx.addCodeFragment(\"}\")\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationCodeOfBooleanSchema(\n    ctx: BuildContext,\n    _schema: Schema.BooleanSchema,\n    nameVar: string,\n    valueVar: string,\n): void {\n    ctx.addCodeFragment(`\n        if (typeof ${valueVar} !== \"boolean\") {\n            errors.push({ code: \"boolean\", args: { name: ${nameVar} }, depth: ${ctx.depth} });\n        }\n    `)\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationCodeOfClassSchema(\n    ctx: BuildContext,\n    { constructor: ctor }: Schema.ClassSchema<any>,\n    nameVar: string,\n    valueVar: string,\n): void {\n    const ctorVar = ctx.addArgument(ctor)\n    ctx.addCodeFragment(`\n        if (!(${valueVar} instanceof ${ctorVar})) {\n            errors.push({ code: \"class\", args: { name: ${nameVar}, constructor: ${ctorVar} }, depth: ${ctx.depth} });\n        }\n    `)\n}\n","import { ValidationError } from \"../validation-error\"\n\ntype LocalType = \"i\" | \"r\" | \"s\"\ntype LocalInfo = Record<LocalType, number>\n\nexport class BuildContext {\n    static readonly NameVar = \"name\"\n    static readonly ValueVar = \"value\"\n\n    private readonly args: any[] = []\n    private readonly code: string[] = ['\"use strict\";', \"var errors = [];\"]\n    // #IF !PROD\n    private indent = 0\n    // */\n    private locals: LocalInfo[] = [{ i: 0, r: 0, s: 0 }]\n    private localsMax: LocalInfo = { i: -1, r: -1, s: -1 }\n\n    get depth(): number {\n        return this.locals.length\n    }\n\n    addArgument(value: any): string {\n        const i = this.args.indexOf(value)\n        if (i !== -1) {\n            return argumentId(i)\n        }\n        const id = argumentId(this.args.length)\n        this.args.push(value)\n        return id\n    }\n\n    addCodeFragment(code: string): void {\n        for (const line0 of code.split(\"\\n\")) {\n            const line = line0.trim()\n            if (line.length === 0) {\n                continue\n            }\n            // eslint-disable-next-line multiline-comment-style\n            /* #IF PROD\n            this.code.push(line)\n            // */\n            // #IF !PROD\n            if (line.startsWith(\"}\")) {\n                this.indent -= 2\n            }\n            this.code.push(\" \".repeat(this.indent) + line)\n            if (line.endsWith(\"{\")) {\n                this.indent += 2\n            }\n            // */\n        }\n    }\n\n    addLocal(type: LocalType): string {\n        return localId(type, this.locals[this.locals.length - 1][type]++)\n    }\n    stackLocalScope(): void {\n        this.locals.push({ ...this.locals[this.locals.length - 1] })\n    }\n    popLocalScope(): void {\n        const locals = this.locals.pop()!\n        const max = this.localsMax\n        for (const type of [\"i\", \"s\", \"r\"] as const) {\n            if (locals[type] > max[type]) {\n                max[type] = locals[type]\n            }\n        }\n    }\n\n    createFunction(): (\n        name: string,\n        value: any,\n    ) => ValidationError.ErrorInfo[] {\n        this.popLocalScope()\n        this.code.push(\"return errors;\")\n\n        const locals: string[] = []\n        for (let i = 0; i < this.localsMax.i; ++i) {\n            locals.push(`${localId(\"i\", i)} = 0`)\n        }\n        for (let i = 0; i < this.localsMax.s; ++i) {\n            locals.push(`${localId(\"s\", i)} = \"\"`)\n        }\n        for (let i = 0; i < this.localsMax.r; ++i) {\n            locals.push(`${localId(\"r\", i)} = null`)\n        }\n        if (locals.length > 0) {\n            this.code[1] = `var errors = [], ${locals.join(\", \")};`\n        }\n\n        const params = this.args.map((_, i) => argumentId(i))\n        const code = this.code.join(\"\\n\")\n        const func: any = new Function(\n            ...params,\n            BuildContext.NameVar,\n            BuildContext.ValueVar,\n            code,\n        ).bind(null, ...this.args)\n\n        // #IF !PROD\n        func.toString = () => {\n            const paramsStr = [\n                ...params,\n                BuildContext.NameVar,\n                BuildContext.ValueVar,\n            ].join(\", \")\n            const bodyStr = code\n                .split(\"\\n\")\n                .map(line => `  ${line}`)\n                .join(\"\\n\")\n            return `function validate(${paramsStr}) {\\n${bodyStr}\\n}`\n        }\n        // */\n\n        return func\n    }\n}\n\nfunction argumentId(i: number): string {\n    return `a${i.toString(36)}`\n}\n\nfunction localId(type: LocalType, i: number): string {\n    return `${type}${i.toString(36)}`\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationCodeOfCustomSchema(\n    ctx: BuildContext,\n    { check, name }: Schema.CustomSchema<any>,\n    nameVar: string,\n    valueVar: string,\n): void {\n    const checkName = JSON.stringify(name)\n    const checkVar = ctx.addArgument(check)\n    ctx.addCodeFragment(`\n        if (!${checkVar}(${valueVar})) {\n            errors.push({ code: \"custom\", args: { name: ${nameVar}, checkFunc: ${checkVar}, checkName: ${checkName} }, depth: ${ctx.depth} });\n        }\n    `)\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationCodeOfEnumSchema(\n    ctx: BuildContext,\n    { values }: Schema.EnumSchema<unknown>,\n    nameVar: string,\n    valueVar: string,\n): void {\n    if (values.length === 0) {\n        throw new Error(\"EnumSchema must have 1 or more values.\")\n    }\n    const simple =\n        values.length < 10 &&\n        values.every(\n            value =>\n                typeof value !== \"function\" &&\n                (typeof value !== \"object\" || value === null) &&\n                typeof value !== \"symbol\",\n        )\n\n    let conditionStr: string\n    let optionsStr: string\n    if (simple) {\n        const valueStrs = values.map(value => {\n            switch (typeof value) {\n                case \"bigint\":\n                    return `${value}n`\n                case \"boolean\":\n                case \"object\":\n                case \"string\":\n                    return JSON.stringify(value)\n                case \"number\":\n                    return Number.isNaN(value)\n                        ? \"Number.NaN\"\n                        : value === Number.POSITIVE_INFINITY\n                        ? \"Number.POSITIVE_INFINITY\"\n                        : value === Number.NEGATIVE_INFINITY\n                        ? \"Number.NEGATIVE_INFINITY\"\n                        : String(value)\n                case \"undefined\":\n                    return \"undefined\"\n\n                //istanbul ignore next\n                default:\n                    throw new Error(`Unknown type: ${typeof value}`)\n            }\n        })\n        conditionStr = valueStrs\n            .map(s =>\n                s === \"Number.NaN\"\n                    ? `!Number.isNaN(${valueVar})`\n                    : `${valueVar} !== ${s}`,\n            )\n            .join(\" && \")\n        optionsStr = `[${valueStrs.join(\", \")}]`\n    } else if (values.length === 1) {\n        const testValueVar = ctx.addArgument(values[0])\n        optionsStr = `[${testValueVar}]`\n        conditionStr = `${valueVar} !== ${testValueVar}`\n    } else {\n        const hasNaN = values.some(value => Number.isNaN(value))\n        const testValuesVar = ctx.addArgument([...values])\n        optionsStr = `${testValuesVar}.slice(0)`\n        conditionStr = hasNaN\n            ? `!Number.isNaN(${valueVar}) && ${testValuesVar}.indexOf(${valueVar}) === -1`\n            : `${testValuesVar}.indexOf(${valueVar}) === -1`\n    }\n\n    ctx.addCodeFragment(`\n        if (${conditionStr}) {\n            errors.push({ code: \"enum\", args: { name: ${nameVar}, values: ${optionsStr} }, depth: ${ctx.depth} });\n        }\n    `)\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationCodeOfFunctionSchema(\n    ctx: BuildContext,\n    _schema: Schema.FunctionSchema,\n    nameVar: string,\n    valueVar: string,\n): void {\n    ctx.addCodeFragment(`\n        if (typeof ${valueVar} !== \"function\") {\n            errors.push({ code: \"function\", args: { name: ${nameVar} }, depth: ${ctx.depth} });\n        }\n    `)\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationCodeOfNumberSchema(\n    ctx: BuildContext,\n    {\n        allowNaN = false,\n        finiteOnly = false,\n        intOnly = false,\n        maxValue,\n        minValue,\n    }: Schema.NumberSchema,\n    nameVar: string,\n    valueVar: string,\n): void {\n    if (intOnly) {\n        if (finiteOnly) {\n            throw new Error(\n                '\"finiteOnly\" and \"intOnly\" cannot be true at the same time.',\n            )\n        }\n        const nanCheck = allowNaN ? ` && !Number.isNaN(${valueVar})` : \"\"\n        ctx.addCodeFragment(`\n            if (!Number.isInteger(${valueVar})${nanCheck}) {\n                errors.push({ code: \"numberIntOnly\", args: { name: ${nameVar} }, depth: ${ctx.depth} });\n        `)\n    } else if (finiteOnly) {\n        const nanCheck = allowNaN ? ` && !Number.isNaN(${valueVar})` : \"\"\n        ctx.addCodeFragment(`\n            if (!Number.isFinite(${valueVar})${nanCheck}) {\n                errors.push({ code: \"numberFiniteOnly\", args: { name: ${nameVar} }, depth: ${ctx.depth} });\n        `)\n    } else {\n        const nanCheck = allowNaN ? \"\" : ` || Number.isNaN(${valueVar})`\n        ctx.addCodeFragment(`\n            if (typeof ${valueVar} !== \"number\"${nanCheck}) {\n                errors.push({ code: \"number\", args: { name: ${nameVar} }, depth: ${ctx.depth} });\n        `)\n    }\n    if (maxValue === undefined && minValue === undefined) {\n        ctx.addCodeFragment(\"}\")\n        return\n    }\n    ctx.addCodeFragment(\"} else {\")\n\n    if (maxValue !== undefined) {\n        if (minValue != null && minValue > maxValue) {\n            throw new Error('\"maxValue\" must be \"minValue\" or greater than it.')\n        }\n        ctx.addCodeFragment(`\n            if (${valueVar} > ${maxValue}) {\n                errors.push({ code: \"numberMaxValue\", args: { name: ${nameVar}, maxValue: ${maxValue} }, depth: ${ctx.depth} });\n            }\n        `)\n    }\n    if (minValue !== undefined) {\n        ctx.addCodeFragment(`\n            if (${valueVar} < ${minValue}) {\n                errors.push({ code: \"numberMinValue\", args: { name: ${nameVar}, minValue: ${minValue} }, depth: ${ctx.depth} });\n            }\n        `)\n    }\n\n    ctx.addCodeFragment(\"}\")\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\nimport { addValidationCodeOfSchema } from \"./schema\"\n\nexport function addValidationCodeOfObjectSchema(\n    ctx: BuildContext,\n    {\n        properties,\n        required = [],\n    }: Schema.ObjectSchema<Record<string, Schema>, string>,\n    nameVar: string,\n    valueVar: string,\n): void {\n    const remainingKeysVar = ctx.addLocal(\"r\")\n\n    ctx.addCodeFragment(`\n        if (typeof ${valueVar} !== \"object\" || ${valueVar} === null) {\n            errors.push({ code: \"object\", args: { name: ${nameVar} }, depth: ${ctx.depth} });\n        } else {\n            ${remainingKeysVar} = Object.keys(${valueVar});\n    `)\n\n    const keys = Object.keys(properties).sort(undefined)\n    if (keys.length > 0) {\n        const iVar = ctx.addLocal(\"i\")\n\n        const missingKeysVar =\n            required.length > 0 ? ctx.addLocal(\"r\") : undefined\n        if (missingKeysVar) {\n            ctx.addCodeFragment(`${missingKeysVar} = [];`)\n        }\n        for (const propertyName of keys) {\n            const propertySchema = properties[propertyName]\n            const propertyNameStr = JSON.stringify(propertyName).slice(1, -1)\n            const isRequired = required.includes(propertyName)\n            ctx.addCodeFragment(`\n                ${iVar} = ${remainingKeysVar}.indexOf(\"${propertyNameStr}\");\n                if (${iVar} !== -1) {\n                    ${remainingKeysVar}.splice(${iVar}, 1);\n            `)\n            if (propertySchema.type !== \"any\") {\n                ctx.stackLocalScope()\n                const propertyNameVar = ctx.addLocal(\"s\")\n                const propertyValueVar = ctx.addLocal(\"r\")\n                ctx.addCodeFragment(`\n                    ${propertyNameVar} = ${nameVar} + \".${propertyNameStr}\";\n                    ${propertyValueVar} = ${valueVar}[\"${propertyNameStr}\"];\n                `)\n                if (!isRequired) {\n                    ctx.addCodeFragment(\n                        `if (${propertyValueVar} !== undefined) {`,\n                    )\n                }\n                addValidationCodeOfSchema(\n                    ctx,\n                    propertySchema,\n                    propertyNameVar,\n                    propertyValueVar,\n                )\n                if (!isRequired) {\n                    ctx.addCodeFragment(\"}\")\n                }\n                ctx.popLocalScope()\n            }\n            if (missingKeysVar && isRequired) {\n                ctx.addCodeFragment(`\n                    } else {\n                        ${missingKeysVar}.push(\"${propertyNameStr}\")\n                    }\n                `)\n            } else {\n                ctx.addCodeFragment(\"}\")\n            }\n        }\n        if (missingKeysVar) {\n            ctx.addCodeFragment(`\n                if (${missingKeysVar}.length > 0) {\n                    errors.push({ code: \"objectRequiredKeys\", args: { name: ${nameVar}, keys: ${missingKeysVar} }, depth: ${ctx.depth} });\n                }\n            `)\n        }\n    }\n    ctx.addCodeFragment(`\n        if (${remainingKeysVar}.length > 0) {\n            errors.push({ code: \"objectUnknownKeys\", args: { name: ${nameVar}, keys: ${remainingKeysVar} }, depth: ${ctx.depth} });\n        }\n    `)\n\n    ctx.addCodeFragment(\"}\")\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\nimport { addValidationCodeOfSchema } from \"./schema\"\n\nexport function addValidationCodeOfRecordSchema(\n    ctx: BuildContext,\n    { properties }: Schema.RecordSchema<Schema>,\n    nameVar: string,\n    valueVar: string,\n): void {\n    ctx.addCodeFragment(`\n        if (typeof ${valueVar} !== \"object\" || ${valueVar} === null) {\n            errors.push({ code: \"object\", args: { name: ${nameVar} }, depth: ${ctx.depth} });\n    `)\n    if (properties.type === \"any\") {\n        ctx.addCodeFragment(\"}\")\n        return\n    }\n    ctx.addCodeFragment(\"} else {\")\n\n    const keysVar = ctx.addLocal(\"r\")\n    const iVar = ctx.addLocal(\"i\")\n    ctx.stackLocalScope()\n    const propertyNameVar = ctx.addLocal(\"s\")\n    const propertyValueVar = ctx.addLocal(\"r\")\n    ctx.addCodeFragment(`\n        ${keysVar} = Object.keys(${valueVar})\n        for (${iVar} = 0; ${iVar} < ${keysVar}.length; ++${iVar}) {\n            ${propertyNameVar} = ${keysVar}[${iVar}];\n            ${propertyValueVar} = ${valueVar}[${propertyNameVar}];\n            ${propertyNameVar} = ${nameVar} + \".\" + ${propertyNameVar};\n    `)\n    addValidationCodeOfSchema(\n        ctx,\n        properties,\n        propertyNameVar,\n        propertyValueVar,\n    )\n    ctx.popLocalScope()\n    ctx.addCodeFragment(\"}\")\n    ctx.addCodeFragment(\"}\")\n}\n","import { MaxStringLength } from \"../constants\"\nimport { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationCodeOfStringSchema(\n    ctx: BuildContext,\n    {\n        maxLength = MaxStringLength,\n        minLength = 0,\n        pattern,\n    }: Schema.StringSchema,\n    nameVar: string,\n    valueVar: string,\n): void {\n    ctx.addCodeFragment(`\n        if (typeof ${valueVar} !== \"string\") {\n            errors.push({ code: \"string\", args: { name: ${nameVar} }, depth: ${ctx.depth} });\n    `)\n    if (\n        maxLength >= MaxStringLength &&\n        minLength <= 0 &&\n        pattern === undefined\n    ) {\n        ctx.addCodeFragment(\"}\")\n        return\n    }\n    ctx.addCodeFragment(\"} else {\")\n\n    if (maxLength < MaxStringLength) {\n        const countCharsVar = ctx.addArgument(countChars)\n        const depth = ctx.depth\n        if (minLength > 0) {\n            if (minLength > maxLength) {\n                throw new Error(\n                    '\"maxLength\" must be \"minLength\" or greater than it.',\n                )\n            }\n            const countVar = ctx.addLocal(\"i\")\n            ctx.addCodeFragment(`\n                ${countVar} = ${countCharsVar}(${valueVar}, ${maxLength + 1});\n                if (${countVar} > ${maxLength}) {\n                    errors.push({ code: \"stringMaxLength\", args: { name: ${nameVar}, maxLength: ${maxLength} }, depth: ${depth} });\n                }\n                if (${countVar} < ${minLength}) {\n                    errors.push({ code: \"stringMinLength\", args: { name: ${nameVar}, minLength: ${minLength} }, depth: ${depth} });\n                }\n            `)\n        } else {\n            const end = maxLength + 1\n            ctx.addCodeFragment(`\n                if (${countCharsVar}(${valueVar}, ${end}) > ${maxLength}) {\n                    errors.push({ code: \"stringMaxLength\", args: { name: ${nameVar}, maxLength: ${maxLength} }, depth: ${depth} });\n                }\n            `)\n        }\n    } else if (minLength > 0) {\n        const countCharsVar = ctx.addArgument(countChars)\n        ctx.addCodeFragment(`\n            if (${countCharsVar}(${valueVar}, ${minLength}) < ${minLength}) {\n                errors.push({ code: \"stringMinLength\", args: { name: ${nameVar}, minLength: ${minLength} }, depth: ${ctx.depth} });\n            }\n        `)\n    }\n\n    if (pattern !== undefined) {\n        ctx.addCodeFragment(`\n            if (!${pattern}.test(${valueVar})) {\n                errors.push({ code: \"stringPattern\", args: { name: ${nameVar}, pattern: ${pattern} }, depth: ${ctx.depth} });\n            }\n        `)\n    }\n\n    ctx.addCodeFragment(\"}\")\n}\n\nfunction countChars(s: string, max: number): number {\n    let count = 0\n    let code = 0\n    for (\n        let i = 0, end = s.length;\n        i < end;\n        i += (code = s.charCodeAt(i)) >= 0xd800 && code <= 0xdbff ? 2 : 1\n    ) {\n        count += 1\n        if (count >= max) {\n            return count\n        }\n    }\n    return count\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationCodeOfSymbolSchema(\n    ctx: BuildContext,\n    _schema: Schema.SymbolSchema,\n    nameVar: string,\n    valueVar: string,\n): void {\n    ctx.addCodeFragment(`\n        if (typeof ${valueVar} !== \"symbol\") {\n            errors.push({ code: \"symbol\", args: { name: ${nameVar} }, depth: ${ctx.depth} });\n        }\n    `)\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\nimport { addValidationCodeOfSchema } from \"./schema\"\n\nexport function addValidationCodeOfTupleSchema(\n    ctx: BuildContext,\n    { elements }: Schema.TupleSchema<readonly Schema[]>,\n    nameVar: string,\n    valueVar: string,\n): void {\n    ctx.addCodeFragment(`\n        if (!Array.isArray(${valueVar})) {\n            errors.push({ code: \"tuple\", args: { name: ${nameVar} }, depth: ${ctx.depth} });\n        } else {\n            if (${valueVar}.length !== ${elements.length}) {\n                errors.push({ code: \"tupleLength\", args: { name: ${nameVar}, length: ${elements.length} }, depth: ${ctx.depth} });\n            }\n    `)\n\n    for (let i = 0; i < elements.length; ++i) {\n        const elementSchema = elements[i]\n        if (elementSchema.type === \"any\") {\n            continue\n        }\n\n        ctx.stackLocalScope()\n        const elementNameVar = ctx.addLocal(\"s\")\n        const elementValueVar = ctx.addLocal(\"r\")\n        ctx.addCodeFragment(`\n            ${elementNameVar} = ${nameVar} + \"[${i}]\";\n            ${elementValueVar} = ${valueVar}[${i}];\n        `)\n        addValidationCodeOfSchema(\n            ctx,\n            elementSchema,\n            elementNameVar,\n            elementValueVar,\n        )\n        ctx.popLocalScope()\n    }\n\n    ctx.addCodeFragment(\"}\")\n}\n","import { Schema } from \"../schema-types\"\nimport { ValidationError } from \"../validation-error\"\nimport { BuildContext } from \"./context\"\nimport { addValidationCodeOfSchema, createValidationOfSchema } from \"./schema\"\n\nexport function addValidationCodeOfUnionSchema(\n    ctx: BuildContext,\n    { schemas: givenSchemas }: Schema.UnionSchema<Schema>,\n    nameVar: string,\n    valueVar: string,\n): void {\n    const schemas = flat(givenSchemas)\n    if (schemas.length === 0) {\n        throw new Error(\"UnionSchema must have 1 or more schemas.\")\n    }\n    if (schemas.length === 1) {\n        addValidationCodeOfSchema(ctx, schemas[0], nameVar, valueVar)\n        return\n    }\n    const validateUnionVar = ctx.addArgument(validateUnion)\n    const validationsVar = ctx.addArgument(\n        schemas.map(createValidationOfSchema),\n    )\n    const schemasVar = ctx.addArgument(schemas)\n    const errorsVar = ctx.addLocal(\"r\")\n    const iVar = ctx.addLocal(\"i\")\n\n    ctx.addCodeFragment(`\n        ${errorsVar} = ${validateUnionVar}(${validationsVar}, ${nameVar}, ${valueVar})\n        if (${errorsVar}.length >= 2) {\n            errors.push({ code: \"union\", args: { name: ${nameVar}, schemas: ${schemasVar} }, depth: ${ctx.depth} });\n        }\n        if (${errorsVar}.length === 1) {\n            for (${iVar} = 0; ${iVar} < ${errorsVar}[0].length; ++${iVar}) {\n                errors.push(${errorsVar}[0][${iVar}])\n            }\n        }\n    `)\n}\n\nconst Any = Object.freeze([Object.freeze({ type: \"any\" as const })])\n\nfunction flat(\n    schemas: readonly Schema[],\n    retv: Exclude<Schema, Schema.UnionSchema<any>>[] = [],\n): readonly Exclude<Schema, Schema.UnionSchema<any>>[] {\n    for (const schema of schemas) {\n        if (schema.type === \"any\") {\n            return Any\n        }\n        if (schema.type === \"union\") {\n            if (flat(schema.schemas, retv) === Any) {\n                return Any\n            }\n        } else {\n            retv.push(schema)\n        }\n    }\n    return retv\n}\n\nfunction validateUnion(\n    validations: readonly ((\n        name: string,\n        value: any,\n    ) => ValidationError.ErrorInfo[])[],\n    name: string,\n    value: any,\n): ValidationError.ErrorInfo[][] {\n    const retv: ValidationError.ErrorInfo[][] = []\n    let maxDepth = -1\n    for (const validate of validations) {\n        const errors = validate(name, value)\n        if (errors.length === 0) {\n            return []\n        }\n        const depth = errors.reduce(\n            (d, e) => Math.min(d, e.depth),\n            Number.MAX_SAFE_INTEGER,\n        )\n        if (depth > maxDepth) {\n            retv.length = 1\n            retv[0] = errors\n            maxDepth = depth\n        } else if (depth === maxDepth) {\n            retv.push(errors)\n        }\n    }\n    return retv\n}\n","import { Schema } from \"../schema-types\"\nimport { ValidationError } from \"../validation-error\"\nimport { addValidationCodeOfArraySchema } from \"./array-schema\"\nimport { addValidationCodeOfBigIntSchema } from \"./bigint-schema\"\nimport { addValidationCodeOfBooleanSchema } from \"./boolean-schema\"\nimport { addValidationCodeOfClassSchema } from \"./class-schema\"\nimport { BuildContext } from \"./context\"\nimport { addValidationCodeOfCustomSchema } from \"./custom-schema\"\nimport { addValidationCodeOfEnumSchema } from \"./enum-schema\"\nimport { addValidationCodeOfFunctionSchema } from \"./function-schema\"\nimport { addValidationCodeOfNumberSchema } from \"./number-schema\"\nimport { addValidationCodeOfObjectSchema } from \"./object-schema\"\nimport { addValidationCodeOfRecordSchema } from \"./record-schema\"\nimport { addValidationCodeOfStringSchema } from \"./string-schema\"\nimport { addValidationCodeOfSymbolSchema } from \"./symbol-schema\"\nimport { addValidationCodeOfTupleSchema } from \"./tuple-schema\"\nimport { addValidationCodeOfUnionSchema } from \"./union-schema\"\n\nconst cache = new WeakMap<\n    Schema,\n    (name: string, value: any) => ValidationError.ErrorInfo[]\n>()\n\nexport function createValidationOfSchema(\n    schema: Schema,\n): (name: string, value: any) => ValidationError.ErrorInfo[] {\n    let validation = cache.get(schema)\n    if (!validation) {\n        validation = addValidationCodeOfSchema(\n            new BuildContext(),\n            schema,\n            BuildContext.NameVar,\n            BuildContext.ValueVar,\n        ).createFunction()\n        cache.set(schema, validation)\n    }\n    return validation\n}\n\nexport function addValidationCodeOfSchema(\n    ctx: BuildContext,\n    schema: Schema,\n    nameVar: string,\n    valueVar: string,\n): BuildContext {\n    switch (schema.type) {\n        case \"any\":\n            break\n        case \"array\":\n            addValidationCodeOfArraySchema(ctx, schema, nameVar, valueVar)\n            break\n        case \"bigint\":\n            addValidationCodeOfBigIntSchema(ctx, schema, nameVar, valueVar)\n            break\n        case \"boolean\":\n            addValidationCodeOfBooleanSchema(ctx, schema, nameVar, valueVar)\n            break\n        case \"class\":\n            addValidationCodeOfClassSchema(ctx, schema, nameVar, valueVar)\n            break\n        case \"custom\":\n            addValidationCodeOfCustomSchema(ctx, schema, nameVar, valueVar)\n            break\n        case \"enum\":\n            addValidationCodeOfEnumSchema(ctx, schema, nameVar, valueVar)\n            break\n        case \"function\":\n            addValidationCodeOfFunctionSchema(ctx, schema, nameVar, valueVar)\n            break\n        case \"number\":\n            addValidationCodeOfNumberSchema(ctx, schema, nameVar, valueVar)\n            break\n        case \"object\":\n            addValidationCodeOfObjectSchema(ctx, schema, nameVar, valueVar)\n            break\n        case \"record\":\n            addValidationCodeOfRecordSchema(ctx, schema, nameVar, valueVar)\n            break\n        case \"string\":\n            addValidationCodeOfStringSchema(ctx, schema, nameVar, valueVar)\n            break\n        case \"symbol\":\n            addValidationCodeOfSymbolSchema(ctx, schema, nameVar, valueVar)\n            break\n        case \"tuple\":\n            addValidationCodeOfTupleSchema(ctx, schema, nameVar, valueVar)\n            break\n        case \"union\":\n            addValidationCodeOfUnionSchema(ctx, schema, nameVar, valueVar)\n            break\n\n        //istanbul ignore next\n        default:\n            throw new Error(`Unknown Schema: ${schema}`)\n    }\n\n    return ctx\n}\n","import { Schema } from \"../schema-types\"\nimport { Message } from \"./message\"\n\nexport const DefaultMessage: Message = {\n    array: ({ name }) => `\"${name}\" must be an array.`,\n    arrayMaxLength: ({ name, maxLength }) =>\n        `The length of \"${name}\" must be ${maxLength} or less than it.`,\n    arrayMinLength: ({ name, minLength }) =>\n        `The length of \"${name}\" must be ${minLength} or greater than it.`,\n    arrayUnique: ({ name }) => `\"${name}\" must not contain duplicate values.`,\n    bigint: ({ name }) => `\"${name}\" must be a bigint value.`,\n    bigintMaxValue: ({ name, maxValue }) =>\n        `\"${name}\" must be ${maxValue}n or less than it.`,\n    bigintMinValue: ({ name, minValue }) =>\n        `\"${name}\" must be ${minValue}n or greater than it.`,\n    boolean: ({ name }) => `\"${name}\" must be a boolean value.`,\n    class: ({ name, constructor: ctor }) =>\n        `\"${name}\" must be an instance of ${ctor.name}.`,\n    custom: ({ name, checkName }) => `\"${name}\" must be ${checkName}.`,\n    enum: ({ name, values }) =>\n        values.length === 1\n            ? `\"${name}\" must be ${valueToString(values[0])}.`\n            : `\"${name}\" must be any of ${listToString(\n                  values,\n                  \"and\",\n                  valueToString,\n              )}.`,\n    function: ({ name }) => `\"${name}\" must be a function.`,\n    number: ({ name }) => `\"${name}\" must be a number.`,\n    numberFiniteOnly: ({ name }) => `\"${name}\" must be a finite number.`,\n    numberIntOnly: ({ name }) => `\"${name}\" must be an integer.`,\n    numberMaxValue: ({ name, maxValue }) =>\n        `\"${name}\" must be ${maxValue} or less than it.`,\n    numberMinValue: ({ name, minValue }) =>\n        `\"${name}\" must be ${minValue} or greater than it.`,\n    object: ({ name }) => `\"${name}\" must be an object.`,\n    objectRequiredKeys: ({ name, keys }) =>\n        keys.length === 1\n            ? `\"${name}\" must have the required property: ${keys[0]}.`\n            : `\"${name}\" must have the required properties: ${keys.join(\",\")}.`,\n    objectUnknownKeys: ({ name, keys }) =>\n        keys.length === 1\n            ? `\"${name}\" must not have unknown property: ${keys[0]}.`\n            : `\"${name}\" must not have unknown properties: ${keys.join(\",\")}.`,\n    string: ({ name }) => `\"${name}\" must be a string.`,\n    stringMaxLength: ({ name, maxLength }) =>\n        `The cheracters of \"${name}\" must be ${maxLength} or less than it.`,\n    stringMinLength: ({ name, minLength }) =>\n        `The cheracters of \"${name}\" must be ${minLength} or more than it.`,\n    stringPattern: ({ name, pattern }) =>\n        `\"${name}\" must match the pattern ${pattern}.`,\n    symbol: ({ name }) => `\"${name}\" must be a symbol.`,\n    tuple: ({ name }) => `\"${name}\" must be a tuple.`,\n    tupleLength: ({ name, length }) =>\n        `The length of \"${name}\" must be ${length}.`,\n    union({ name, schemas }) {\n        const options = ([] as string[]).concat(...schemas.map(schemaToString))\n        return options.length === 2\n            ? `\"${name}\" must be ${listToString(options, \"or\")}.`\n            : `\"${name}\" must be any of ${listToString(options, \"and\")}.`\n    },\n    validation({ name, errors }) {\n        if (errors.length === 1) {\n            return errors[0]\n        }\n        return `\"${name}\" has multiple validation errors:\\n${errors\n            .map(e => `- ${e}`)\n            .join(\"\\n\")}`\n    },\n}\n\nfunction valueToString(value: any): string {\n    switch (typeof value) {\n        case \"bigint\":\n            return `${value}n`\n        case \"function\":\n            return `[function ${value.name || \"(anonymous)\"}]`\n        case \"string\":\n            return JSON.stringify(value)\n        default:\n            return String(value)\n    }\n}\n\nfunction schemaToString(\n    schema: Exclude<Schema, Schema.AnySchema | Schema.UnionSchema<any>>,\n): string | string[] {\n    switch (schema.type) {\n        case \"array\":\n            return \"an array\"\n        case \"bigint\":\n            return \"a bigint value\"\n        case \"boolean\":\n            return \"a boolean value\"\n        case \"class\":\n            return `a ${schema.constructor.name} instance`\n        case \"custom\":\n            return schema.name\n        case \"enum\":\n            return schema.values.map(valueToString)\n        case \"function\":\n            return \"a function\"\n        case \"number\":\n            return \"a number\"\n        case \"object\":\n        case \"record\":\n            return \"an object\"\n        case \"string\":\n            return \"a string\"\n        case \"symbol\":\n            return \"a symbol\"\n        case \"tuple\":\n            return \"a tuple\"\n\n        //istanbul ignore next\n        default:\n            return \"an unknown value\"\n    }\n}\n\nfunction listToString<T>(\n    xs: readonly T[],\n    kind: \"and\" | \"or\",\n    select: (x: T) => string = String,\n): string {\n    switch (xs.length) {\n        case 0:\n            return \"\"\n        case 1:\n            return select(xs[0])\n        case 2:\n            return `${select(xs[0])} ${kind} ${select(xs[1])}`\n        default: {\n            const ys = xs.map(select)\n            const last = ys.pop()\n            return `${ys.join(\", \")}, ${kind} ${last}`\n        }\n    }\n}\n","import { Message } from \"./message\"\n\nexport class ValidationError extends Error {\n    readonly errors: readonly ValidationError.ErrorInfo[]\n\n    constructor(\n        message: Message,\n        name: string,\n        errors: ValidationError.ErrorInfo[],\n    ) {\n        super(toMessage(message, name, errors))\n        this.errors = errors\n        ;(Error as any).captureStackTrace?.(this, ValidationError)\n    }\n}\nexport namespace ValidationError {\n    export type ErrorCode = Exclude<keyof Message, \"validation\">\n    export type ErrorInfo = {\n        [P in ErrorCode]: {\n            code: P\n            args: Parameters<Message[P]>[0]\n            depth: number\n        }\n    }[ErrorCode]\n}\n\nfunction toMessage(\n    message: Message,\n    name: string,\n    errors: ValidationError.ErrorInfo[],\n): string {\n    return message.validation({\n        name,\n        errors: errors.map(e => message[e.code](e.args as any)),\n    })\n}\n","import { createValidationOfSchema } from \"./builder\"\nimport { DefaultMessage, Message } from \"./message\"\nimport { TypeOf } from \"./real-types\"\nimport { Schema } from \"./schema-types\"\nimport { ValidationError } from \"./validation-error\"\n\nexport type Validate<T extends Schema> = (\n    name: string,\n    value: any,\n) => asserts value is TypeOf<T>\n\nexport function createValidation<T extends Schema>(\n    schema: T,\n    { messages = DefaultMessage }: createValidation.Options = {},\n): Validate<T> {\n    const validate = createValidationOfSchema(schema)\n    return (name, value) => {\n        const errors = validate(name, value)\n        if (errors.length > 0) {\n            throw new ValidationError(messages, name, errors)\n        }\n    }\n}\nexport namespace createValidation {\n    export type Options = {\n        messages?: Message\n    }\n}\n","export class Cache<T extends object, U> {\n    private readonly map = new WeakMap<T, U>()\n    private readonly factory: (key: T) => U\n\n    constructor(factory: (key: T) => U) {\n        this.factory = factory\n    }\n\n    get(key: T): U {\n        if (this.map.has(key)) {\n            return this.map.get(key)!\n        }\n\n        const value = this.factory(key)\n        this.map.set(key, value)\n        return value\n    }\n}\n","import { Cache } from \"./cache\"\nimport {\n    MaxArrayLength,\n    MaxInt16,\n    MaxInt32,\n    MaxInt8,\n    MaxStringLength,\n    MaxUint16,\n    MaxUint32,\n    MaxUint8,\n    MinInt16,\n    MinInt32,\n    MinInt8,\n} from \"./constants\"\nimport { Schema } from \"./schema-types\"\n\nconst any: Schema.AnySchema = { type: \"any\" }\nconst anyBigInt: Schema.BigIntSchema = {\n    type: \"bigint\",\n    minValue: undefined,\n    maxValue: undefined,\n}\nconst bigInt64: Schema.BigIntSchema = {\n    type: \"bigint\",\n    minValue: BigInt(\"-9223372036854775808\"),\n    maxValue: BigInt(\"9223372036854775807\"),\n}\nconst bigUint64: Schema.BigIntSchema = {\n    type: \"bigint\",\n    minValue: BigInt(\"0\"),\n    maxValue: BigInt(\"18446744073709551615\"),\n}\nconst anyBoolean: Schema.BooleanSchema = { type: \"boolean\" }\nconst constantNull: Schema.EnumSchema<null> = { type: \"enum\", values: [null] }\nconst anyFunction: Schema.FunctionSchema = { type: \"function\" }\nconst anyNumber: Schema.NumberSchema = {\n    type: \"number\",\n    allowNaN: false,\n    finiteOnly: false,\n    intOnly: false,\n    maxValue: undefined,\n    minValue: undefined,\n}\nconst anyFiniteNumber: Schema.NumberSchema = {\n    type: \"number\",\n    allowNaN: false,\n    finiteOnly: true,\n    intOnly: false,\n    maxValue: undefined,\n    minValue: undefined,\n}\nconst anyInteger: Schema.NumberSchema = {\n    type: \"number\",\n    allowNaN: false,\n    finiteOnly: false,\n    intOnly: true,\n    maxValue: undefined,\n    minValue: undefined,\n}\nconst int8: Schema.NumberSchema = {\n    type: \"number\",\n    allowNaN: false,\n    finiteOnly: false,\n    intOnly: true,\n    maxValue: MaxInt8,\n    minValue: MinInt8,\n}\nconst int16: Schema.NumberSchema = {\n    type: \"number\",\n    allowNaN: false,\n    finiteOnly: false,\n    intOnly: true,\n    maxValue: MaxInt16,\n    minValue: MinInt16,\n}\nconst int32: Schema.NumberSchema = {\n    type: \"number\",\n    allowNaN: false,\n    finiteOnly: false,\n    intOnly: true,\n    maxValue: MaxInt32,\n    minValue: MinInt32,\n}\nconst uint8: Schema.NumberSchema = {\n    type: \"number\",\n    allowNaN: false,\n    finiteOnly: false,\n    intOnly: true,\n    maxValue: MaxUint8,\n    minValue: 0,\n}\nconst uint16: Schema.NumberSchema = {\n    type: \"number\",\n    allowNaN: false,\n    finiteOnly: false,\n    intOnly: true,\n    maxValue: MaxUint16,\n    minValue: 0,\n}\nconst uint32: Schema.NumberSchema = {\n    type: \"number\",\n    allowNaN: false,\n    finiteOnly: false,\n    intOnly: true,\n    maxValue: MaxUint32,\n    minValue: 0,\n}\nconst anyObject: Schema.RecordSchema<Schema.AnySchema> = {\n    type: \"record\",\n    properties: any,\n}\nconst anyString: Schema.StringSchema = {\n    type: \"string\",\n    maxLength: MaxStringLength,\n    minLength: 0,\n    pattern: undefined,\n}\nconst anySymbol: Schema.SymbolSchema = { type: \"symbol\" }\nconst anyArrayCache = new Cache(\n    (elements: Schema): Schema.ArraySchema<Schema> => ({\n        type: \"array\",\n        elements,\n        maxLength: MaxArrayLength,\n        minLength: 0,\n        unique: false,\n    }),\n)\nconst classCache = new Cache(\n    (\n        // eslint-disable-next-line no-shadow\n        constructor: Schema.ClassSchema<any>[\"constructor\"],\n    ): Schema.ClassSchema<any> => ({\n        type: \"class\",\n        constructor,\n    }),\n)\n\n/* eslint-disable class-methods-use-this */\nclass SchemaFactories {\n    /**\n     * The schema for any values.\n     */\n    any(): Schema.AnySchema {\n        return any\n    }\n\n    /**\n     * The schema for array instances.\n     * @param elements The schema of element types.\n     * @param options The options.\n     */\n    array(): Schema.ArraySchema<Schema.AnySchema>\n\n    /**\n     * The schema for array instances.\n     * @param elements The schema of element types.\n     * @param options The options.\n     */\n    array<T extends Schema>(\n        elements: T,\n        options?: Omit<Schema.ArraySchema<T>, \"type\" | \"elements\">,\n    ): Schema.ArraySchema<T>\n\n    // Implementation\n    array(\n        elements: Schema = any,\n        {\n            maxLength = MaxArrayLength,\n            minLength = 0,\n            unique = false,\n        }: Omit<Schema.ArraySchema<any>, \"type\" | \"elements\"> = {},\n    ): Schema.ArraySchema<Schema> {\n        if (maxLength >= MaxArrayLength && minLength <= 0 && !unique) {\n            return anyArrayCache.get(elements)\n        }\n        return { type: \"array\", elements, maxLength, minLength, unique }\n    }\n\n    /**\n     * The schema for bigint values.\n     * @param options The options.\n     */\n    bigInt({\n        maxValue,\n        minValue,\n    }: Omit<Schema.BigIntSchema, \"type\"> = {}): Schema.BigIntSchema {\n        if (maxValue === undefined && minValue === undefined) {\n            return anyBigInt\n        }\n        return { type: \"bigint\", maxValue, minValue }\n    }\n\n    /**\n     * The schema for 64 bits signed integers.\n     */\n    bigInt64 = bigInt64\n\n    /**\n     * The schema for 64 bits unsigned integers.\n     */\n    bigUint64 = bigUint64\n\n    /**\n     * The schema for true or false.\n     */\n    boolean(): Schema.BooleanSchema {\n        return anyBoolean\n    }\n\n    /**\n     * The schema for specific class instances.\n     * @param constructor The constructor to use `instanceof` operations.\n     */\n    instanceOf<T>(\n        // eslint-disable-next-line no-shadow\n        constructor: Schema.ClassSchema<T>[\"constructor\"],\n    ): Schema.ClassSchema<T> {\n        return classCache.get(constructor)\n    }\n\n    /**\n     * The schema for user-defined checks.\n     * @param name The name of the valid values. This name will be shown in error messages.\n     * @param check The check.\n     */\n    custom<T>(name: string, check: (x: any) => x is T): Schema.CustomSchema<T> {\n        return { type: \"custom\", check, name }\n    }\n\n    /**\n     * The schema for any of listed values.\n     * @param firstValue One of allowed values.\n     * @param restValues Rest of allowed values.\n     */\n    enum<T, U extends readonly any[]>(\n        firstValue: T,\n        ...restValues: U\n    ): Schema.EnumSchema<T | U[number]>\n\n    // Implementation\n    enum<T extends readonly any[]>(...values: T): Schema.EnumSchema<T[number]> {\n        if (values.length === 1 && values[0] === null) {\n            return constantNull as Schema.EnumSchema<any>\n        }\n        return { type: \"enum\", values }\n    }\n\n    /**\n     * The schema for null.\n     * Equivalent to `schemas.const(null)` and `schemas.enum(null)`.\n     */\n    null = constantNull\n\n    /**\n     * The schema for any functions.\n     */\n    function(): Schema.FunctionSchema {\n        return anyFunction\n    }\n\n    /**\n     * The schema for numbers.\n     * @param options The options.\n     */\n    number({\n        allowNaN = false,\n        finiteOnly = false,\n        intOnly = false,\n        maxValue,\n        minValue,\n    }: Omit<Schema.NumberSchema, \"type\"> = {}): Schema.NumberSchema {\n        if (!allowNaN && maxValue === undefined && minValue === undefined) {\n            if (intOnly) {\n                if (!finiteOnly) {\n                    return anyInteger\n                }\n            } else if (finiteOnly) {\n                return anyFiniteNumber\n            } else {\n                return anyNumber\n            }\n        }\n        return {\n            type: \"number\",\n            allowNaN,\n            finiteOnly,\n            intOnly,\n            maxValue,\n            minValue,\n        }\n    }\n\n    /**\n     * The schema for 8 bits signed integers.\n     */\n    int8 = int8\n\n    /**\n     * The schema for 16 bits signed integers.\n     */\n    int16 = int16\n\n    /**\n     * The schema for 32 bits signed integers.\n     */\n    int32 = int32\n\n    /**\n     * The schema for 8 bits unsigned integers.\n     */\n    uint8 = uint8\n\n    /**\n     * The schema for 16 bits unsigned integers.\n     */\n    uint16 = uint16\n\n    /**\n     * The schema for 32 bits unsigned integers.\n     */\n    uint32 = uint32\n\n    /**\n     * The schema for any objects.\n     */\n    object(): Schema.RecordSchema<Schema.AnySchema>\n\n    /**\n     * The schema for plain objects. All properties are required.\n     * @param properties The schema of known properties.\n     */\n    object<TProperties extends Record<any, Schema>>(\n        properties: TProperties,\n    ): Schema.ObjectSchema<TProperties, keyof TProperties>\n\n    // Implementation\n    object(\n        properties?: Record<any, Schema>,\n    ):\n        | Schema.RecordSchema<Schema.AnySchema>\n        | Schema.ObjectSchema<Record<any, Schema>, any> {\n        if (properties === undefined) {\n            return anyObject\n        }\n        return { type: \"object\", properties, required: Object.keys(properties) }\n    }\n\n    /**\n     * The schema for plain objects. All properties are optional.\n     * @param properties The schema of known properties.\n     */\n    partialObject<TProperties extends Record<any, Schema>>(\n        properties: TProperties,\n    ): Schema.ObjectSchema<TProperties, never>\n\n    /**\n     * The schema for plain objects.\n     * @param properties The schema of known properties.\n     * @param required The names of required properties.\n     */\n    partialObject<\n        TProperties extends Record<any, Schema>,\n        TRequired extends (keyof TProperties)[]\n    >(\n        properties: TProperties,\n        required: TRequired,\n    ): Schema.ObjectSchema<TProperties, TRequired[number]>\n\n    // Implementation\n    partialObject<\n        TProperties extends Record<any, Schema>,\n        TRequired extends (keyof TProperties)[]\n    >(\n        properties: TProperties,\n        required?: TRequired,\n    ): Schema.ObjectSchema<TProperties, TRequired[number]> {\n        if (required && required.length > 0) {\n            return { type: \"object\", properties, required }\n        }\n        return { type: \"object\", properties }\n    }\n\n    /**\n     * The schema for any objects.\n     */\n    record(): Schema.RecordSchema<Schema.AnySchema>\n\n    /**\n     * The schema for plain objects.\n     * @param properties The schema of properties.\n     */\n    record<T extends Schema>(properties: T): Schema.RecordSchema<T>\n\n    // Implementation\n    record(properties: Schema = any): Schema.RecordSchema<Schema> {\n        if (properties.type === \"any\") {\n            return anyObject\n        }\n        return { type: \"record\", properties }\n    }\n\n    /**\n     * The schema for strings.\n     * @param options The options.\n     */\n    string({\n        maxLength = MaxStringLength,\n        minLength = 0,\n        pattern,\n    }: Omit<Schema.StringSchema, \"type\"> = {}): Schema.StringSchema {\n        if (maxLength >= MaxStringLength && minLength <= 0 && pattern == null) {\n            return anyString\n        }\n        return { type: \"string\", maxLength, minLength, pattern }\n    }\n\n    /**\n     * The schema for any symbols.\n     */\n    symbol(): Schema.SymbolSchema {\n        return anySymbol\n    }\n\n    /**\n     * The schema for tuples.\n     * @param elements The schema of elements.\n     */\n    tuple<T extends readonly Schema[]>(...elements: T): Schema.TupleSchema<T> {\n        return { type: \"tuple\", elements }\n    }\n\n    /**\n     * The schema for any of listed schemas.\n     * @param firstSchema One of allowed schemas.\n     * @param restSchemas Rest of allowed schemas.\n     */\n    anyOf<T extends Schema, U extends readonly Schema[]>(\n        firstSchema: T,\n        ...restSchemas: U\n    ): Schema.UnionSchema<T | U[number]>\n\n    // Implementation\n    anyOf<T extends readonly Schema[]>(\n        ...schemas: T\n    ): Schema.UnionSchema<T[number]> {\n        return { type: \"union\", schemas }\n    }\n}\n/* eslint-enable class-methods-use-this */\n\n/**\n * The schema factories.\n */\nexport const schemas = Object.freeze(new SchemaFactories())\n","import { createValidationOfSchema } from \"./builder\"\nimport { DefaultMessage, Message } from \"./message\"\nimport { TypeOf } from \"./real-types\"\nimport { Schema } from \"./schema-types\"\nimport { ValidationError } from \"./validation-error\"\n\nexport function validate<T extends Schema>(\n    schema: T,\n    name: string,\n    value: any,\n    { messages = DefaultMessage }: validate.Options = {},\n): asserts value is TypeOf<T> {\n    const errors = createValidationOfSchema(schema)(name, value)\n    if (errors.length > 0) {\n        throw new ValidationError(messages, name, errors)\n    }\n}\nexport namespace validate {\n    export type Options = {\n        messages?: Message\n    }\n}\n"],"names":[],"mappings":"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"}