{"version":3,"file":"index.js","sources":["src/builder/any-schema.ts","src/constants.ts","src/builder/array-schema.ts","src/builder/bigint-schema.ts","src/builder/boolean-schema.ts","src/builder/class-schema.ts","src/builder/context.ts","src/builder/custom-schema.ts","src/builder/enum-schema.ts","src/builder/function-schema.ts","src/builder/number-schema.ts","src/builder/object-schema.ts","src/builder/record-schema.ts","src/builder/string-schema.ts","src/builder/symbol-schema.ts","src/builder/tuple-schema.ts","src/builder/union-schema.ts","src/builder/schema.ts","src/message/default-message.ts","src/validation-error.ts","src/create-validate.ts","src/schema-factories.ts","src/validate.ts"],"sourcesContent":["import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationOfAnySchema(\n    ctx: BuildContext,\n    _schemaKey: string,\n    _schema: Schema.Any,\n): string {\n    return ctx.addValidation(\n        (_locals, _name, _value, _depth, errors) => `return ${errors};`,\n    )\n}\n","export const MaxInt8 = 127\nexport const MaxInt16 = 32767\nexport const MaxInt32 = 2147483647\nexport const MaxInt64 = BigInt(\"9223372036854775807\")\nexport const MaxUint8 = 255\nexport const MaxUint16 = 65535\nexport const MaxUint32 = 4294967295\nexport const MaxUint64 = BigInt(\"18446744073709551615\")\nexport const MinInt8 = -128\nexport const MinInt16 = -32768\nexport const MinInt32 = -2147483648\nexport const MinInt64 = BigInt(\"-9223372036854775808\")\nexport const MaxArrayLength = MaxUint32\nexport const MaxStringLength = 9007199254740991\n","import { MaxArrayLength } from \"../constants\"\nimport { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\nimport { addValidation } from \"./schema\"\n\nexport function addValidationOfArraySchema(\n    ctx: BuildContext,\n    schemaKey: string,\n    {\n        elements,\n        maxLength = MaxArrayLength,\n        minLength = 0,\n        unique = false,\n    }: Schema.Array<Schema>,\n): string {\n    return ctx.addValidation(function* (locals, name, value, depth, errors) {\n        const shouldCheckElements =\n            elements.type !== \"any\" ||\n            maxLength < MaxArrayLength ||\n            minLength > 0 ||\n            unique\n\n        yield `\n            if (!Array.isArray(${value})) {\n                ${errors}.push({ code: \"array\", args: { name: ${name} }, depth: ${depth} });\n        `\n\n        if (shouldCheckElements) {\n            yield \"} else {\"\n\n            const length = locals.add(\"0\")\n            yield `${length} = ${value}.length;`\n            if (maxLength < MaxArrayLength) {\n                if (maxLength < minLength) {\n                    throw new Error(\n                        '\"maxLength\" must be \"minLength\" or greater than it.',\n                    )\n                }\n                if (minLength > 0) {\n                    yield `\n                        if (${length} > ${maxLength}) {\n                            ${errors}.push({ code: \"arrayMaxLength\", args: { name: ${name}, maxLength: ${maxLength} }, depth: ${depth} + 1 });\n                        } else if (${length} < ${minLength}) {\n                            ${errors}.push({ code: \"arrayMinLength\", args: { name: ${name}, minLength: ${minLength} }, depth: ${depth} + 1 });\n                        }\n                    `\n                } else {\n                    yield `\n                        if (${length} > ${maxLength}) {\n                            ${errors}.push({ code: \"arrayMaxLength\", args: { name: ${name}, maxLength: ${maxLength} }, depth: ${depth} + 1 });\n                        }\n                    `\n                }\n            } else if (minLength > 0) {\n                yield `\n                    if (${length} < ${minLength}) {\n                        ${errors}.push({ code: \"arrayMinLength\", args: { name: ${name}, minLength: ${minLength} }, depth: ${depth} + 1 });\n                    }\n                `\n            }\n            if (unique) {\n                const isUnique = addIsUnique(ctx)\n                yield `\n                    if (!${isUnique}(${value}, ${length})) {\n                        ${errors}.push({ code: \"arrayUnique\", args: { name: ${name} }, depth: ${depth} + 1 });\n                    }\n                `\n            }\n            if (elements.type !== \"any\") {\n                const validate = addValidation(\n                    ctx,\n                    `${schemaKey}.elements`,\n                    elements,\n                )\n                const i = locals.add(\"0\")\n                yield `\n                    for (${i} = 0; ${i} < ${length}; ++${i}) {\n                        ${validate}(${name} + \"[\" + ${i} + \"]\", ${value}[${i}], ${depth} + 1, ${errors});\n                    }\n                `\n            }\n        }\n\n        yield `\n            }\n            return ${errors};\n        `\n    })\n}\n\nfunction addIsUnique(ctx: BuildContext): string {\n    return ctx.addFunction((locals, xs, length) => {\n        const i = locals.add(\"0\")\n        const j = locals.add(\"0\")\n        const x = locals.add(\"null\")\n        return `\n            for (; ${i} < ${length}; ++${i}) {\n                ${x} = ${xs}[${i}];\n                for (${j} = 0; ${j} < ${i}; ++${j}) {\n                    if (${x} === ${xs}[${j}]) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        `\n    })\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationOfBigIntSchema(\n    ctx: BuildContext,\n    _schemaKey: string,\n    { maxValue, minValue }: Schema.BigInt,\n): string {\n    return ctx.addValidation(function* (_locals, name, value, depth, errors) {\n        yield `\n            if (typeof ${value} !== \"bigint\") {\n                ${errors}.push({ code: \"bigint\", args: { name: ${name} }, depth: ${depth} });\n        `\n\n        if (maxValue !== undefined || minValue !== undefined) {\n            yield \"} else {\"\n\n            if (maxValue !== undefined) {\n                if (minValue !== undefined) {\n                    if (minValue > maxValue) {\n                        throw new Error(\n                            '\"maxValue\" must be \"minValue\" or greater than it.',\n                        )\n                    }\n                    yield `\n                        if (${value} > ${maxValue}n) {\n                            ${errors}.push({ code: \"bigintMaxValue\", args: { name: ${name}, maxValue: ${maxValue}n }, depth: ${depth} + 1 });\n                        } else if (${value} < ${minValue}n) {\n                            ${errors}.push({ code: \"bigintMinValue\", args: { name: ${name}, minValue: ${minValue}n }, depth: ${depth} + 1 });\n                        }\n                    `\n                } else {\n                    yield `\n                        if (${value} > ${maxValue}n) {\n                            ${errors}.push({ code: \"bigintMaxValue\", args: { name: ${name}, maxValue: ${maxValue}n }, depth: ${depth} + 1 });\n                        }\n                    `\n                }\n            } else if (minValue !== undefined) {\n                yield `\n                    if (${value} < ${minValue}n) {\n                        ${errors}.push({ code: \"bigintMinValue\", args: { name: ${name}, minValue: ${minValue}n }, depth: ${depth} + 1 });\n                    }\n                `\n            }\n        }\n\n        yield `\n            }\n            return ${errors};\n        `\n    })\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationOfBooleanSchema(\n    ctx: BuildContext,\n    _schemaKey: string,\n    _schema: Schema.Boolean,\n): string {\n    return ctx.addValidation(\n        (_locals, name, value, depth, errors) => `\n            if (typeof ${value} !== \"boolean\") {\n                ${errors}.push({ code: \"boolean\", args: { name: ${name} }, depth: ${depth} });\n            }\n            return ${errors};\n        `,\n    )\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationOfClassSchema(\n    ctx: BuildContext,\n    schemaKey: string,\n    schema: Schema.Class<any>,\n): string {\n    return ctx.addValidation((_locals, name, value, depth, errors) => {\n        // eslint-disable-next-line no-shadow\n        const constructor = ctx.addConstant(\n            `${schemaKey}.constructor`,\n            schema.constructor,\n        )\n        return `\n            if (!(${value} instanceof ${constructor})) {\n                ${errors}.push({ code: \"class\", args: { name: ${name}, constructor: ${constructor} }, depth: ${depth} });\n            }\n            return ${errors};\n        `\n    })\n}\n","import { Schema } from \"../schema-types\"\nimport { ValidationError } from \"../validation-error\"\n\nexport class BuildContext {\n    private readonly constants: unknown[] = []\n    private readonly functionMap = new Map<string, string>()\n    private readonly flyweightMap = new Map<string, object>()\n    private readonly code: string[] = ['\"use strict\";']\n    private indent = 0\n\n    addValidation(\n        createBody: (\n            locals: BuildContext.Locals,\n            name: string,\n            value: string,\n            depth: string,\n            errors: string,\n        ) => string | IterableIterator<string>,\n    ): string {\n        return this.addFunction(createBody)\n    }\n\n    addFunction(\n        createBody: (\n            locals: BuildContext.Locals,\n            ...params: string[]\n        ) => string | IterableIterator<string>,\n    ): string {\n        const numArgs = Math.max(0, createBody.length - 1)\n        const locals = new Locals()\n        const params = Array.from({ length: numArgs }, () => locals.addArgs())\n        const bodyGen = createBody(locals, ...params)\n        const body =\n            typeof bodyGen === \"string\" ? bodyGen : [...bodyGen].join(\"\\n\")\n        const code = locals.getVariableDeclaration() + body\n        let id = this.functionMap.get(code)\n        if (id === undefined) {\n            id = constantId(this.constants.length)\n            this.constants.push({})\n            this.addCodeFragment(`function ${id}(${params.join(\", \")}) {`)\n            this.addCodeFragment(code)\n            this.addCodeFragment(\"}\")\n            this.functionMap.set(code, id)\n        }\n        return id\n    }\n\n    private addCodeFragment(code: string): void {\n        for (const line0 of code.split(\"\\n\")) {\n            const line = line0.trim()\n            if (line.length === 0) {\n                continue\n            }\n            // eslint-disable-next-line multiline-comment-style\n            /* #IF PROD\n            this.code.push(line)\n            // */\n            // #IF !PROD\n            if (line.startsWith(\"}\")) {\n                this.indent -= 2\n            }\n            this.code.push(\" \".repeat(this.indent) + line)\n            if (line.endsWith(\"{\")) {\n                this.indent += 2\n            }\n            // */\n        }\n    }\n\n    mapSchema(validationId: string, schemaKey: string): string {\n        let ref = this.flyweightMap.get(validationId)\n        if (!ref) {\n            ref = {}\n            this.flyweightMap.set(validationId, ref)\n        }\n        return this.addConstant(schemaKey, ref)\n    }\n\n    addConstant(valueExpr: string, valueRef: unknown): string {\n        const i = this.constants.indexOf(valueRef)\n        if (i !== -1) {\n            return constantId(i)\n        }\n\n        const id = constantId(this.constants.length)\n        this.addCodeFragment(`var ${id} = ${valueExpr};`)\n        this.constants.push(valueRef)\n        return id\n    }\n\n    build(\n        schema: Schema,\n        validationId: string,\n    ): (name: string, value: any) => ValidationError.ErrorInfo[] {\n        this.addCodeFragment(`\n            return function validate(name, value) {\n                return ${validationId}(name, value, 0, []);\n            };\n        `)\n        const code = this.code.join(\"\\n\")\n        try {\n            const func: any = new Function(\"$schema\", code)(schema)\n\n            // #IF !PROD\n            func.toString = () => {\n                const bodyStr = code\n                    .split(\"\\n\")\n                    .map(line => `  ${line}`)\n                    .join(\"\\n\")\n                return `var validate = (function($schema) {\\n${bodyStr}\\n})({});`\n            }\n            // */\n\n            return func\n        } catch (error) {\n            //istanbul ignore next\n            if (error instanceof SyntaxError) {\n                error.message += ` in the code:\\n${code}`\n            }\n            //istanbul ignore next\n            throw error\n        }\n    }\n}\nexport namespace BuildContext {\n    export interface Locals {\n        add(initExpr: string): string\n    }\n}\n\nconst Chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nclass Locals {\n    private numArgs = 0\n    private localInits: string[] = []\n\n    addArgs(): string {\n        return localId(this.numArgs++)\n    }\n\n    add(initExpr: string): string {\n        const id = localId(this.numArgs + this.localInits.length)\n        this.localInits.push(`${id} = ${initExpr}`)\n        return id\n    }\n\n    getVariableDeclaration(): string {\n        if (this.localInits.length > 0) {\n            return `var ${this.localInits.join(\", \")};\\n`\n        }\n        return \"\"\n    }\n}\n\nfunction constantId(i: number): string {\n    return `_${i.toString(36)}`\n}\n\nfunction localId(i: number): string {\n    //istanbul ignore if\n    if (i >= Chars.length) {\n        throw new Error(\"Too many locals\")\n    }\n    return Chars[i]\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationOfCustomSchema(\n    ctx: BuildContext,\n    schemaKey: string,\n    schema: Schema.Custom<any>,\n): string {\n    return ctx.addValidation((_locals, name, value, depth, errors) => {\n        const checkName = JSON.stringify(schema.name)\n        const checkFunc = ctx.addConstant(`${schemaKey}.check`, schema.check)\n        return `\n            if (!${checkFunc}(${value})) {\n                ${errors}.push({ code: \"custom\", args: { name: ${name}, checkFunc: ${checkFunc}, checkName: ${checkName} }, depth: ${depth} });\n            }\n            return ${errors};\n        `\n    })\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationOfEnumSchema(\n    ctx: BuildContext,\n    schemaKey: string,\n    { values }: Schema.Enum<unknown>,\n): string {\n    if (values.length === 0) {\n        throw new Error(\"EnumSchema must have 1 or more values.\")\n    }\n    return ctx.addValidation((_locals, name, value, depth, errors) => {\n        const valueStrs = values.map(valueToString(ctx, schemaKey))\n        const conditionStr = valueStrs\n            .map(stringToCondition(value))\n            .join(\" && \")\n        const optionsStr = valueStrs.join(\", \")\n        return `\n            if (${conditionStr}) {\n                ${errors}.push({ code: \"enum\", args: { name: ${name}, values: [${optionsStr}] }, depth: ${depth} });\n            }\n            return ${errors};\n        `\n    })\n}\n\nfunction valueToString(\n    ctx: BuildContext,\n    key: string,\n): (value: unknown, i: number) => string {\n    return (value, i) => {\n        switch (typeof value) {\n            case \"bigint\":\n                return `${value}n`\n            case \"boolean\":\n                return String(value)\n            case \"function\":\n            case \"symbol\":\n                return ctx.addConstant(`${key}.values[${i}]`, value)\n            case \"number\":\n                return Number.isNaN(value)\n                    ? \"Number.NaN\"\n                    : value === Number.POSITIVE_INFINITY\n                    ? \"Number.POSITIVE_INFINITY\"\n                    : value === Number.NEGATIVE_INFINITY\n                    ? \"Number.NEGATIVE_INFINITY\"\n                    : String(value)\n            case \"object\":\n                return value === null\n                    ? \"null\"\n                    : ctx.addConstant(`${key}.values[${i}]`, value)\n            case \"string\":\n                return JSON.stringify(value)\n            case \"undefined\":\n                return \"undefined\"\n\n            //istanbul ignore next\n            default:\n                throw new Error(`Unknown type: ${typeof value}`)\n        }\n    }\n}\n\nfunction stringToCondition(value: string): (criteria: string) => string {\n    return criteria =>\n        criteria === \"Number.NaN\"\n            ? `!Number.isNaN(${value})`\n            : `${value} !== ${criteria}`\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationOfFunctionSchema(\n    ctx: BuildContext,\n    _schemaKey: string,\n    _schema: Schema.Function,\n): string {\n    return ctx.addValidation(\n        (_locals, name, value, depth, errors) => `\n            if (typeof ${value} !== \"function\") {\n                ${errors}.push({ code: \"function\", args: { name: ${name} }, depth: ${depth} });\n            }\n            return ${errors};\n        `,\n    )\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationOfNumberSchema(\n    ctx: BuildContext,\n    _schemaKey: string,\n    {\n        allowInfinity = false,\n        allowNaN = false,\n        intOnly = false,\n        maxValue,\n        minValue,\n    }: Schema.Number,\n): string {\n    // eslint-disable-next-line complexity\n    return ctx.addValidation(function* (_locals, name, value, depth, errors) {\n        if (\n            allowInfinity &&\n            allowNaN &&\n            !intOnly &&\n            maxValue === undefined &&\n            minValue === undefined\n        ) {\n            yield `\n                if (typeof ${value} !== \"number\") {\n                    ${errors}.push({ code: \"number\", args: { name: ${name} }, depth: ${depth} });\n            `\n        } else {\n            const checker = intOnly ? \"isInteger\" : \"isFinite\"\n            const code = intOnly ? \"numberIntOnly\" : \"number\"\n\n            yield `if (!Number.${checker}(${value})) {`\n            if (allowInfinity) {\n                if (allowNaN) {\n                    yield `if (${value} !== Number.POSITIVE_INFINITY && ${value} !== Number.NEGATIVE_INFINITY && !Number.isNaN(${value})) {`\n                } else {\n                    yield `\n                        if (Number.isNaN(${value})) {\n                            ${errors}.push({ code: \"numberDisallowNaN\", args: { name: ${name} }, depth: ${depth} });\n                        } else if (${value} !== Number.POSITIVE_INFINITY && ${value} !== Number.NEGATIVE_INFINITY) {\n                    `\n                }\n            } else if (allowNaN) {\n                yield `\n                    if (${value} === Number.POSITIVE_INFINITY || ${value} === Number.NEGATIVE_INFINITY) {\n                        ${errors}.push({ code: \"numberDisallowInfinity\", args: { name: ${name} }, depth: ${depth} });\n                    } else if (!Number.isNaN(${value})) {\n                `\n            } else {\n                yield `\n                    if (${value} === Number.POSITIVE_INFINITY || ${value} === Number.NEGATIVE_INFINITY) {\n                        ${errors}.push({ code: \"numberDisallowInfinity\", args: { name: ${name} }, depth: ${depth} });\n                    } else if (Number.isNaN(${value})) {\n                        ${errors}.push({ code: \"numberDisallowNaN\", args: { name: ${name} }, depth: ${depth} });\n                    } else {\n                `\n            }\n            yield `\n                    ${errors}.push({ code: \"${code}\", args: { name: ${name} }, depth: ${depth} });\n                }\n            `\n\n            if (maxValue !== undefined || minValue !== undefined) {\n                yield \"} else {\"\n\n                if (maxValue !== undefined) {\n                    if (minValue !== undefined) {\n                        if (minValue > maxValue) {\n                            throw new Error(\n                                '\"maxValue\" must be \"minValue\" or greater than it.',\n                            )\n                        }\n                        yield `\n                            if (${value} > ${maxValue}) {\n                                ${errors}.push({ code: \"numberMaxValue\", args: { name: ${name}, maxValue: ${maxValue} }, depth: ${depth} + 1 });\n                            } else if (${value} < ${minValue}) {\n                                ${errors}.push({ code: \"numberMinValue\", args: { name: ${name}, minValue: ${minValue} }, depth: ${depth} + 1 });\n                            }\n                        `\n                    } else {\n                        yield `\n                            if (${value} > ${maxValue}) {\n                                ${errors}.push({ code: \"numberMaxValue\", args: { name: ${name}, maxValue: ${maxValue} }, depth: ${depth} + 1 });\n                            }\n                        `\n                    }\n                } else if (minValue !== undefined) {\n                    yield `\n                        if (${value} < ${minValue}) {\n                            ${errors}.push({ code: \"numberMinValue\", args: { name: ${name}, minValue: ${minValue} }, depth: ${depth} + 1 });\n                        }\n                    `\n                }\n            }\n        }\n\n        yield `\n            }\n            return ${errors};\n        `\n    })\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\nimport { addValidation } from \"./schema\"\n\nexport function addValidationOfObjectSchema(\n    ctx: BuildContext,\n    schemaKey: string,\n    {\n        allowUnknown = false,\n        properties,\n        required = [],\n    }: Schema.Object<Record<string, Schema>, string, boolean>,\n): string {\n    return ctx.addValidation(function* (locals, name, value, depth, errors) {\n        const requiredKeys = Array.from(new Set(required)).sort(undefined)\n        const optionalKeys = Object.keys(properties).sort(undefined)\n        const shouldCheckProperties =\n            !allowUnknown ||\n            optionalKeys.some(k => properties[k].type !== \"any\")\n\n        yield `\n            if (typeof ${value} !== \"object\" || ${value} === null) {\n                ${errors}.push({ code: \"object\", args: { name: ${name} }, depth: ${depth} });\n        `\n\n        if (shouldCheckProperties) {\n            yield \"} else {\"\n\n            const collectKeys = addCollectKeys(ctx)\n            const remainKeys = locals.add(\"null\")\n            yield `${remainKeys} = ${collectKeys}(${value});`\n\n            let missingKeys = \"\"\n            if (requiredKeys.length > 0) {\n                missingKeys = locals.add(\"null\")\n                yield `${missingKeys} = [];`\n                for (const propertyName of requiredKeys) {\n                    const i = optionalKeys.indexOf(propertyName)\n                    if (i === -1) {\n                        throw new Error(\n                            `\"${propertyName}\" was in \"${schemaKey}.required\", so it must exist in \"${schemaKey}.properties\".`,\n                        )\n                    } else {\n                        optionalKeys.splice(i, 1)\n                    }\n                    const propertySchema = properties[propertyName]\n                    const propertyNameStr = JSON.stringify(propertyName).slice(\n                        1,\n                        -1,\n                    )\n\n                    if (propertySchema.type === \"any\") {\n                        yield `\n                            if (!${remainKeys}.delete(\"${propertyNameStr}\")) {\n                                ${missingKeys}.push(\"${propertyNameStr}\");\n                            }\n                        `\n                    } else {\n                        const validationId = addValidation(\n                            ctx,\n                            `${schemaKey}.properties[\"${propertyNameStr}\"]`,\n                            propertySchema,\n                        )\n                        yield `\n                            if (${remainKeys}.delete(\"${propertyNameStr}\")) {\n                                ${validationId}(${name} + \".${propertyNameStr}\", ${value}[\"${propertyNameStr}\"], ${depth} + 1, ${errors});\n                            } else {\n                                ${missingKeys}.push(\"${propertyNameStr}\");\n                            }\n                        `\n                    }\n                }\n            }\n            if (optionalKeys.length > 0) {\n                const propValue = locals.add(\"null\")\n                for (const propertyName of optionalKeys) {\n                    const propertySchema = properties[propertyName]\n                    const propertyNameStr = JSON.stringify(propertyName).slice(\n                        1,\n                        -1,\n                    )\n\n                    if (propertySchema.type === \"any\") {\n                        if (!allowUnknown) {\n                            yield `${remainKeys}.delete(\"${propertyNameStr}\");`\n                        }\n                    } else {\n                        const validationId = addValidation(\n                            ctx,\n                            `${schemaKey}.properties[\"${propertyNameStr}\"]`,\n                            propertySchema,\n                        )\n                        yield `\n                            if (${remainKeys}.delete(\"${propertyNameStr}\") && (${propValue} = ${value}[\"${propertyNameStr}\"]) !== undefined) {\n                                ${validationId}(${name} + \".${propertyNameStr}\", ${propValue}, ${depth} + 1, ${errors});\n                            }\n                        `\n                    }\n                }\n            }\n            if (missingKeys) {\n                yield `\n                    if (${missingKeys}.length > 0) {\n                        ${errors}.push({ code: \"objectRequiredKeys\", args: { name: ${name}, keys: ${missingKeys} }, depth: ${depth} + 1 });\n                    }\n                `\n            }\n            if (!allowUnknown) {\n                const setToArray = addSetToArray(ctx)\n                yield `\n                    if (${remainKeys}.size > 0) {\n                        ${errors}.push({ code: \"objectUnknownKeys\", args: { name: ${name}, keys: ${setToArray}(${remainKeys}) }, depth: ${depth} + 1 });\n                    }\n                `\n            }\n        }\n\n        yield `\n            }\n            return ${errors};\n        `\n    })\n}\n\nfunction addCollectKeys(ctx: BuildContext): string {\n    return ctx.addFunction((locals, obj) => {\n        const keys = locals.add(\"new Set()\")\n        const key = locals.add('\"\"')\n        return `\n            for (${key} in ${obj}) ${keys}.add(${key});\n            return ${keys};\n        `\n    })\n}\n\nfunction addSetToArray(ctx: BuildContext): string {\n    return ctx.addFunction((locals, set) => {\n        const retv = locals.add(\"[]\")\n        return `\n            ${set}.forEach(function(x) { ${retv}.push(x) });\n            return ${retv}.sort(undefined);\n        `\n    })\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\nimport { addValidation } from \"./schema\"\n\nexport function addValidationOfRecordSchema(\n    ctx: BuildContext,\n    schemaKey: string,\n    { properties }: Schema.Record<Schema>,\n): string {\n    return ctx.addValidation(function* (locals, name, value, depth, errors) {\n        yield `\n            if (typeof ${value} !== \"object\" || ${value} === null) {\n                ${errors}.push({ code: \"object\", args: { name: ${name} }, depth: ${depth} });\n        `\n\n        if (properties.type !== \"any\") {\n            yield \"} else {\"\n\n            const validate = addValidation(\n                ctx,\n                `${schemaKey}.properties`,\n                properties,\n            )\n            const keys = locals.add(\"null\")\n            const key = locals.add('\"\"')\n            const i = locals.add(\"0\")\n            yield `\n                ${keys} = Object.keys(${value}).sort(undefined);\n                for (; ${i} < ${keys}.length; ++${i}) {\n                    ${key} = ${keys}[${i}]\n                    ${validate}(${name} + \".\" + ${key}, ${value}[${key}], ${depth} + 1, ${errors});\n                }\n            `\n        }\n\n        yield `\n            }\n            return ${errors};\n        `\n    })\n}\n","import { MaxStringLength } from \"../constants\"\nimport { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationOfStringSchema(\n    ctx: BuildContext,\n    _schemaKey: string,\n    { maxLength = MaxStringLength, minLength = 0, pattern }: Schema.String,\n): string {\n    return ctx.addValidation(function* (locals, name, value, depth, errors) {\n        const shouldCheckContent =\n            maxLength < MaxStringLength ||\n            minLength > 0 ||\n            pattern !== undefined\n        yield `\n            if (typeof ${value} !== \"string\") {\n                ${errors}.push({ code: \"string\", args: { name: ${name} }, depth: ${depth} });\n        `\n\n        if (shouldCheckContent) {\n            yield \"} else {\"\n\n            let countChars = \"\"\n            if (maxLength < MaxStringLength || minLength > 0) {\n                countChars = addCountChars(ctx)\n            }\n            if (maxLength < MaxStringLength) {\n                const end = maxLength + 1\n                if (minLength > 0) {\n                    if (minLength > maxLength) {\n                        throw new Error(\n                            '\"maxLength\" must be \"minLength\" or greater than it.',\n                        )\n                    }\n                    const count = locals.add(\"0\")\n                    yield `\n                        ${count} = ${countChars}(${value}, ${end});\n                        if (${count} > ${maxLength}) {\n                            ${errors}.push({ code: \"stringMaxLength\", args: { name: ${name}, maxLength: ${maxLength} }, depth: ${depth} + 1 });\n                        } else if (${count} < ${minLength}) {\n                            ${errors}.push({ code: \"stringMinLength\", args: { name: ${name}, minLength: ${minLength} }, depth: ${depth} + 1 });\n                        }\n                    `\n                } else {\n                    yield `\n                        if (${countChars}(${value}, ${end}) > ${maxLength}) {\n                            ${errors}.push({ code: \"stringMaxLength\", args: { name: ${name}, maxLength: ${maxLength} }, depth: ${depth} + 1 });\n                        }\n                    `\n                }\n            } else if (minLength > 0) {\n                yield `\n                    if (${countChars}(${value}, ${minLength}) < ${minLength}) {\n                        ${errors}.push({ code: \"stringMinLength\", args: { name: ${name}, minLength: ${minLength} }, depth: ${depth} + 1 });\n                    }\n                `\n            }\n\n            if (pattern !== undefined) {\n                yield `\n                    if (!${pattern}.test(${value})) {\n                        ${errors}.push({ code: \"stringPattern\", args: { name: ${name}, pattern: ${pattern} }, depth: ${depth} + 1 });\n                    }\n                `\n            }\n        }\n\n        yield `\n            }\n            return ${errors};\n        `\n    })\n}\n\nfunction addCountChars(ctx: BuildContext): string {\n    return ctx.addFunction((locals, str, end) => {\n        const count = locals.add(\"0\")\n        const code = locals.add(\"0\")\n        const i = locals.add(\"0\")\n        const length = locals.add(`${str}.length`)\n        return `\n            while (${i} < ${length}) {\n                ${count} += 1;\n                if (${count} >= ${end}) {\n                    return ${count};\n                }\n                ${i} += (${code} = ${str}.charCodeAt(${i})) >= 0xd800 && ${code} <= 0xdbff ? 2 : 1;\n            }\n            return ${count}\n        `\n    })\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\n\nexport function addValidationOfSymbolSchema(\n    ctx: BuildContext,\n    _schemaKey: string,\n    _schema: Schema.Symbol,\n): string {\n    return ctx.addValidation(\n        (_locals, name, value, depth, errors) => `\n            if (typeof ${value} !== \"symbol\") {\n                ${errors}.push({ code: \"symbol\", args: { name: ${name} }, depth: ${depth} });\n            }\n            return ${errors};\n        `,\n    )\n}\n","import { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\nimport { addValidation } from \"./schema\"\n\nexport function addValidationOfTupleSchema(\n    ctx: BuildContext,\n    schemaKey: string,\n    { elements }: Schema.Tuple<readonly Schema[]>,\n): string {\n    return ctx.addValidation(function* (_locals, name, value, depth, errors) {\n        const length = elements.length\n        yield `\n            if (!Array.isArray(${value})) {\n                ${errors}.push({ code: \"tuple\", args: { name: ${name} }, depth: ${depth} });\n            } else {\n                if (${value}.length !== ${length}) {\n                    ${errors}.push({ code: \"tupleLength\", args: { name: ${name}, length: ${length} }, depth: ${depth} });\n                }\n        `\n\n        for (let i = 0; i < length; ++i) {\n            const elementSchema = elements[i]\n            if (elementSchema.type === \"any\") {\n                continue\n            }\n\n            const validate = addValidation(\n                ctx,\n                `${schemaKey}.elements[${i}]`,\n                elementSchema,\n            )\n            yield `\n                ${validate}(${name} + \"[${i}]\", ${value}[${i}], ${depth} + 1, ${errors});\n            `\n        }\n\n        yield `\n            }\n            return ${errors};\n        `\n    })\n}\n","import { MaxInt32 } from \"../constants\"\nimport { Schema } from \"../schema-types\"\nimport { BuildContext } from \"./context\"\nimport { addValidation } from \"./schema\"\n\nexport function addValidationOfUnionSchema(\n    ctx: BuildContext,\n    schemaKey: string,\n    { schemas }: Schema.Union<Schema>,\n): string {\n    const flattened = flatten(`${schemaKey}.schemas`, schemas)\n    if (flattened.length === 0) {\n        throw new Error(\"UnionSchema must have 1 or more schemas.\")\n    }\n    if (flattened.length === 1) {\n        return addValidation(\n            ctx,\n            flattened[0].childSchemaKey,\n            flattened[0].childSchema,\n        )\n    }\n\n    const validationIds: string[] = []\n    const schemaIds: string[] = []\n    for (const { childSchemaKey, childSchema } of flattened) {\n        const validationId = addValidation(ctx, childSchemaKey, childSchema)\n        if (validationIds.includes(validationId)) {\n            continue\n        }\n        const schemaId = ctx.mapSchema(validationId, childSchemaKey)\n\n        validationIds.push(validationId)\n        schemaIds.push(schemaId)\n    }\n\n    const validateUnion = addValidateUnion(ctx)\n    const validationsStr = validationIds.join(\", \")\n    const schemasStr = schemaIds.join(\", \")\n    return ctx.addValidation(\n        (_locals, name, value, depth, errors) =>\n            `return ${validateUnion}(${name}, ${value}, ${depth}, ${errors}, [${schemasStr}], [${validationsStr}]);`,\n    )\n}\n\nfunction flatten(\n    key: string,\n    schemas: readonly Schema[],\n    flattened: {\n        childSchemaKey: string\n        childSchema: Exclude<Schema, Schema.Union<any>>\n    }[] = [],\n): {\n    childSchemaKey: string\n    childSchema: Exclude<Schema, Schema.Union<any>>\n}[] {\n    for (let i = 0; i < schemas.length; ++i) {\n        const childSchema = schemas[i]\n        const childSchemaKey = `${key}[${i}]`\n        if (childSchema.type === \"any\") {\n            return [{ childSchemaKey, childSchema }]\n        }\n        if (childSchema.type === \"union\") {\n            const retv = flatten(\n                `${childSchemaKey}.schemas`,\n                childSchema.schemas,\n                flattened,\n            )\n            if (retv !== flattened) {\n                return retv\n            }\n        } else {\n            flattened.push({ childSchemaKey, childSchema })\n        }\n    }\n    return flattened\n}\n\nfunction addValidateUnion(ctx: BuildContext): string {\n    return ctx.addFunction(\n        (locals, name, value, depth, errors, schemas, validates) => {\n            const maxDepth = MaxInt32 >> 1\n            const reduceMinDepthVar = addReduceMinDepth(ctx)\n            const currentErrors = locals.add(\"null\")\n            const thisErrors = locals.add(\"null\")\n            const currentMaxDepth = locals.add(\"-1\")\n            const thisDepth = locals.add(\"0\")\n            const i = locals.add(\"0\")\n            return `\n                for (; ${i} < ${validates}.length; ++${i}) {\n                    ${thisErrors} = ${validates}[${i}](${name}, ${value}, ${depth}, []);\n                    if (${thisErrors}.length === 0) {\n                        return ${errors};\n                    }\n                    ${thisDepth} = ${thisErrors}.reduce(${reduceMinDepthVar}, ${maxDepth})\n                    if (${thisDepth} > ${currentMaxDepth}) {\n                        ${currentErrors} = ${thisErrors};\n                        ${currentMaxDepth} = ${thisDepth};\n                    } else if (${thisDepth} === ${currentMaxDepth}) {\n                        ${currentErrors} = null;\n                    }\n                }\n                if (${currentErrors} !== null) {\n                    for (${i} = 0; ${i} < ${currentErrors}.length; ++${i}) {\n                        ${errors}.push(${currentErrors}[${i}]);\n                    }\n                } else {\n                    ${errors}.push({ code: \"union\", args: { name: ${name}, schemas: ${schemas} }, depth: ${depth} });\n                }\n                return ${errors};\n            `\n        },\n    )\n}\n\nfunction addReduceMinDepth(ctx: BuildContext): string {\n    return ctx.addFunction(\n        (_locals, minDepth, error) => `\n            return ${minDepth} <= ${error}.depth ? ${minDepth} : ${error}.depth;\n        `,\n    )\n}\n","import { Schema } from \"../schema-types\"\nimport { ValidationError } from \"../validation-error\"\nimport { addValidationOfAnySchema } from \"./any-schema\"\nimport { addValidationOfArraySchema } from \"./array-schema\"\nimport { addValidationOfBigIntSchema } from \"./bigint-schema\"\nimport { addValidationOfBooleanSchema } from \"./boolean-schema\"\nimport { addValidationOfClassSchema } from \"./class-schema\"\nimport { BuildContext } from \"./context\"\nimport { addValidationOfCustomSchema } from \"./custom-schema\"\nimport { addValidationOfEnumSchema } from \"./enum-schema\"\nimport { addValidationOfFunctionSchema } from \"./function-schema\"\nimport { addValidationOfNumberSchema } from \"./number-schema\"\nimport { addValidationOfObjectSchema } from \"./object-schema\"\nimport { addValidationOfRecordSchema } from \"./record-schema\"\nimport { addValidationOfStringSchema } from \"./string-schema\"\nimport { addValidationOfSymbolSchema } from \"./symbol-schema\"\nimport { addValidationOfTupleSchema } from \"./tuple-schema\"\nimport { addValidationOfUnionSchema } from \"./union-schema\"\n\nconst cache = new WeakMap<\n    Schema,\n    (name: string, value: any) => ValidationError.ErrorInfo[]\n>()\n\nexport function createValidationOfSchema(\n    schema: Schema,\n): (name: string, value: any) => ValidationError.ErrorInfo[] {\n    let validation = cache.get(schema)\n    if (!validation) {\n        const ctx = new BuildContext()\n        const id = addValidation(ctx, \"$schema\", schema)\n        validation = ctx.build(schema, id)\n        cache.set(schema, validation)\n    }\n    return validation\n}\n\nexport function addValidation(\n    ctx: BuildContext,\n    key: string,\n    schema: Schema,\n): string {\n    switch (schema.type) {\n        case \"any\":\n            return addValidationOfAnySchema(ctx, key, schema)\n        case \"array\":\n            return addValidationOfArraySchema(ctx, key, schema)\n        case \"bigint\":\n            return addValidationOfBigIntSchema(ctx, key, schema)\n        case \"boolean\":\n            return addValidationOfBooleanSchema(ctx, key, schema)\n        case \"class\":\n            return addValidationOfClassSchema(ctx, key, schema)\n        case \"custom\":\n            return addValidationOfCustomSchema(ctx, key, schema)\n        case \"enum\":\n            return addValidationOfEnumSchema(ctx, key, schema)\n        case \"function\":\n            return addValidationOfFunctionSchema(ctx, key, schema)\n        case \"number\":\n            return addValidationOfNumberSchema(ctx, key, schema)\n        case \"object\":\n            return addValidationOfObjectSchema(ctx, key, schema)\n        case \"record\":\n            return addValidationOfRecordSchema(ctx, key, schema)\n        case \"string\":\n            return addValidationOfStringSchema(ctx, key, schema)\n        case \"symbol\":\n            return addValidationOfSymbolSchema(ctx, key, schema)\n        case \"tuple\":\n            return addValidationOfTupleSchema(ctx, key, schema)\n        case \"union\":\n            return addValidationOfUnionSchema(ctx, key, schema)\n\n        //istanbul ignore next\n        default:\n            throw new Error(`Unknown Schema: ${schema}`)\n    }\n}\n","import { Schema } from \"../schema-types\"\nimport { Message } from \"./message\"\n\n/**\n * The default error message generator.\n */\nexport const DefaultMessage: Message = {\n    array: ({ name }) => `\"${name}\" must be an array.`,\n    arrayMaxLength({ name, maxLength }) {\n        const length = plural(maxLength, \"item\")\n        return `\"${name}\" must contain less than or equal to ${length}.`\n    },\n    arrayMinLength: ({ name, minLength }) =>\n        minLength === 1\n            ? `\"${name}\" must not be empty.`\n            : `\"${name}\" must contain more than or equal to ${minLength} items.`,\n    arrayUnique: ({ name }) => `\"${name}\" must not contain duplicate values.`,\n    bigint: ({ name }) => `\"${name}\" must be a bigint value.`,\n    bigintMaxValue: ({ name, maxValue }) =>\n        `\"${name}\" must be less than or equal to ${maxValue}n.`,\n    bigintMinValue: ({ name, minValue }) =>\n        `\"${name}\" must be greater than or equal to ${minValue}n.`,\n    boolean: ({ name }) => `\"${name}\" must be a boolean value.`,\n    class: ({ name, constructor: ctor }) =>\n        `\"${name}\" must be an instance of ${ctor.name || \"Anonymous class\"}.`,\n    custom: ({ name, checkName }) => `\"${name}\" must be ${checkName}.`,\n    enum({ name, values }) {\n        const options = values.map(valueToString).filter(isNotDuplicateValue)\n        if (options.length <= 2) {\n            return `\"${name}\" must be ${listToString(options, \"or\")}.`\n        }\n        return `\"${name}\" must be any of ${listToString(options, \"and\")}.`\n    },\n    function: ({ name }) => `\"${name}\" must be a function.`,\n    number: ({ name }) => `\"${name}\" must be a number.`,\n    numberDisallowInfinity: ({ name }) => `\"${name}\" must not be Infinity.`,\n    numberDisallowNaN: ({ name }) => `\"${name}\" must not be NaN.`,\n    numberIntOnly: ({ name }) => `\"${name}\" must be an integer.`,\n    numberMaxValue: ({ name, maxValue }) =>\n        `\"${name}\" must be less than or equal to ${maxValue}.`,\n    numberMinValue: ({ name, minValue }) =>\n        `\"${name}\" must be greater than or equal to ${minValue}.`,\n    object: ({ name }) => `\"${name}\" must be an object.`,\n    objectRequiredKeys: ({ name, keys }) =>\n        keys.length === 1\n            ? `\"${name}\" must have the required property: ${keys[0]}.`\n            : `\"${name}\" must have the required properties: ${keys.join(\",\")}.`,\n    objectUnknownKeys: ({ name, keys }) =>\n        keys.length === 1\n            ? `\"${name}\" must not have unknown property: ${keys[0]}.`\n            : `\"${name}\" must not have unknown properties: ${keys.join(\",\")}.`,\n    string: ({ name }) => `\"${name}\" must be a string.`,\n    stringMaxLength({ name, maxLength }) {\n        const length = plural(maxLength, \"character\")\n        return `\"${name}\" must be less than or equal to ${length}.`\n    },\n    stringMinLength: ({ name, minLength }) =>\n        minLength === 1\n            ? `\"${name}\" must not be empty.`\n            : `\"${name}\" must be more than or equal to ${minLength} characters.`,\n    stringPattern: ({ name, pattern }) =>\n        `\"${name}\" must match the pattern ${pattern}.`,\n    symbol: ({ name }) => `\"${name}\" must be a symbol.`,\n    tuple: ({ name }) => `\"${name}\" must be a tuple.`,\n    tupleLength: ({ name, length }) =>\n        `\"${name}\" must contain exactly ${plural(length, \"item\")}.`,\n    union({ name, schemas }) {\n        const options = ([] as string[])\n            .concat(...schemas.map(schemaToString))\n            .filter(isNotDuplicateValue)\n        return options.length === 2\n            ? `\"${name}\" must be ${listToString(options, \"or\")}.`\n            : `\"${name}\" must be any of ${listToString(options, \"and\")}.`\n    },\n    validation({ name, errors }) {\n        if (errors.length === 1) {\n            return errors[0]\n        }\n        return `\"${name}\" has ${errors.length} validation errors:\\n${errors\n            .map(e => `- ${e}`)\n            .join(\"\\n\")}`\n    },\n}\n\nfunction valueToString(value: any): string {\n    switch (typeof value) {\n        case \"bigint\":\n            return `${value}n`\n        case \"function\":\n            return `[function ${value.name || \"(anonymous)\"}]`\n        case \"string\":\n            return JSON.stringify(value)\n        default:\n            return String(value)\n    }\n}\n\nfunction schemaToString(\n    schema: Exclude<Schema, Schema.Any | Schema.Union<any>>,\n): string | string[] {\n    switch (schema.type) {\n        case \"array\":\n            return \"an array\"\n        case \"bigint\":\n            return \"a bigint value\"\n        case \"boolean\":\n            return \"a boolean value\"\n        case \"class\":\n            return `a ${schema.constructor.name} instance`\n        case \"custom\":\n            return schema.name\n        case \"enum\":\n            return schema.values.map(valueToString)\n        case \"function\":\n            return \"a function\"\n        case \"number\":\n            return \"a number\"\n        case \"object\":\n        case \"record\":\n            return \"an object\"\n        case \"string\":\n            return \"a string\"\n        case \"symbol\":\n            return \"a symbol\"\n        case \"tuple\":\n            return \"a tuple\"\n\n        //istanbul ignore next\n        default:\n            return \"an unknown value\"\n    }\n}\n\nfunction listToString(xs: readonly string[], kind: \"and\" | \"or\"): string {\n    if (xs.length <= 2) {\n        return xs.join(` ${kind} `)\n    }\n\n    const ys = [...xs]\n    const last = ys.pop()\n    return `${ys.join(\", \")}, ${kind} ${last}`\n}\n\nfunction plural(n: number, unit: string): string {\n    return `${n} ${unit}${n === 1 ? \"\" : \"s\"}`\n}\n\nfunction isNotDuplicateValue(x: string, i: number, xs: string[]): boolean {\n    for (let j = 0; j < i; ++j) {\n        if (x === xs[j]) {\n            return false\n        }\n    }\n    return true\n}\n","import { Message } from \"./message\"\n\n/**\n * Validation errors.\n */\nexport class ValidationError extends Error {\n    /**\n     * The errors.\n     * Every error has `code` and `args`.\n     */\n    readonly errors: readonly ValidationError.ErrorInfo[]\n\n    /**\n     * Initialize this instance.\n     * @param message The message generator.\n     * @param name The target name.\n     * @param errors The errors.\n     */\n    constructor(\n        message: Message,\n        name: string,\n        errors: ValidationError.ErrorInfo[],\n    ) {\n        super(toMessage(message, name, errors))\n        this.errors = errors\n        ;(Error as any).captureStackTrace?.(this, ValidationError)\n    }\n}\nexport namespace ValidationError {\n    /**\n     * The error code.\n     */\n    export type ErrorCode = Exclude<keyof Message, \"validation\">\n    /**\n     * The pair of a error code and arguments.\n     */\n    export type ErrorInfo = {\n        [P in ErrorCode]: {\n            code: P\n            args: Parameters<Message[P]>[0]\n            depth: number\n        }\n    }[ErrorCode]\n}\n\nfunction toMessage(\n    message: Message,\n    name: string,\n    errors: ValidationError.ErrorInfo[],\n): string {\n    return message.validation({\n        name,\n        errors: errors.map(e => message[e.code](e.args as any)),\n    })\n}\n","import { createValidationOfSchema } from \"./builder\"\nimport { DefaultMessage, Message } from \"./message\"\nimport { TypeOf } from \"./real-types\"\nimport { Schema } from \"./schema-types\"\nimport { ValidationError } from \"./validation-error\"\n\n/**\n * The type of validation functions.\n *\n * The validation function has two parameters.\n * - `value` ... The value to validate.\n * - `options` ... Optional. The options.\n *\n * If the `value` passed the validation, the `value` gets the specific type that\n * is computed from the schema `T`. Otherwise, the validation function throws a\n * validation error.\n */\nexport type Validate<T extends Schema> = (\n    value: any,\n    options?: Validate.Options,\n) => asserts value is TypeOf<T>\n\nexport namespace Validate {\n    /**\n     * The options of validation functions.\n     */\n    export type Options = {\n        /**\n         * The error message generator.\n         */\n        messages?: Message\n        /**\n         * The name of the target value.\n         * This will be used in error messages.\n         */\n        name?: string\n    }\n}\n\n/**\n * Compile the validation function of a schema object.\n *\n * Once compiled, it validates values efficiently.\n *\n * The validation code is cached for each schema object into a `WeakMap` object.\n * When GC collected the schema object, the validation code of that is abandoned\n * together.\n *\n * @param schema The schema of the validation.\n * @param options The options.\n * @returns The validation function of the schema.\n */\nexport function createValidation<T extends Schema>(\n    schema: T,\n    { defaultMessages = DefaultMessage }: createValidation.Options = {},\n): Validate<T> {\n    const validateFn = createValidationOfSchema(schema)\n    return function validate(\n        value,\n        { messages = defaultMessages, name = \"value\" } = {},\n    ) {\n        const errors = validateFn(name, value)\n        if (errors.length > 0) {\n            throw new ValidationError(messages, name, errors)\n        }\n    }\n}\n\nexport namespace createValidation {\n    /**\n     * The options of validation function compilation.\n     */\n    export type Options = {\n        /**\n         * The error message generator.\n         */\n        defaultMessages?: Message\n    }\n}\n","import {\n    MaxArrayLength,\n    MaxInt16,\n    MaxInt32,\n    MaxInt64,\n    MaxInt8,\n    MaxStringLength,\n    MaxUint16,\n    MaxUint32,\n    MaxUint64,\n    MaxUint8,\n    MinInt16,\n    MinInt32,\n    MinInt64,\n    MinInt8,\n} from \"./constants\"\nimport { Schema } from \"./schema-types\"\n\n/* eslint-disable class-methods-use-this */\nclass SchemaFactories {\n    /**\n     * The schema for any values.\n     */\n    any(): Schema.Any {\n        return { type: \"any\" }\n    }\n\n    /**\n     * The schema for array instances.\n     * @param elements The schema of element types.\n     * @param options The options.\n     */\n    array(): Schema.Array<Schema.Any>\n\n    /**\n     * The schema for array instances.\n     * @param elements The schema of element types.\n     * @param options The options.\n     */\n    array<T extends Schema>(\n        elements: T,\n        options?: Omit<Schema.Array<T>, \"type\" | \"elements\">,\n    ): Schema.Array<T>\n\n    // Implementation\n    array(\n        elements: Schema = { type: \"any\" },\n        {\n            maxLength = MaxArrayLength,\n            minLength = 0,\n            unique = false,\n        }: Omit<Schema.Array<any>, \"type\" | \"elements\"> = {},\n    ): Schema.Array<Schema> {\n        return { type: \"array\", elements, maxLength, minLength, unique }\n    }\n\n    /**\n     * The schema for bigint values.\n     * @param options The options.\n     */\n    bigInt({\n        maxValue,\n        minValue,\n    }: Omit<Schema.BigInt, \"type\"> = {}): Schema.BigInt {\n        return { type: \"bigint\", maxValue, minValue }\n    }\n\n    /**\n     * The schema for 64 bits signed integers.\n     */\n    bigInt64: Schema.BigInt = {\n        type: \"bigint\",\n        minValue: MinInt64,\n        maxValue: MaxInt64,\n    }\n\n    /**\n     * The schema for 64 bits unsigned integers.\n     */\n    bigUint64: Schema.BigInt = {\n        type: \"bigint\",\n        minValue: BigInt(\"0\"),\n        maxValue: MaxUint64,\n    }\n\n    /**\n     * The schema for true or false.\n     */\n    boolean(): Schema.Boolean {\n        return { type: \"boolean\" }\n    }\n\n    /**\n     * The schema for specific class instances.\n     * @param constructor The constructor to use `instanceof` operations.\n     */\n    instanceOf<T>(\n        // eslint-disable-next-line no-shadow\n        constructor: Schema.Class<T>[\"constructor\"],\n    ): Schema.Class<T> {\n        return { type: \"class\", constructor }\n    }\n\n    /**\n     * The schema for user-defined checks.\n     * @param name The name of the valid values. This name will be shown in error messages.\n     * @param check The check.\n     */\n    custom<T>(name: string, check: (x: any) => x is T): Schema.Custom<T> {\n        return { type: \"custom\", check, name }\n    }\n\n    /**\n     * The schema for any of listed values.\n     * @param firstValue One of allowed values.\n     * @param restValues Rest of allowed values.\n     */\n    enum<T, U extends readonly any[]>(\n        firstValue: T,\n        ...restValues: U\n    ): Schema.Enum<T | U[number]>\n\n    // Implementation\n    enum<T extends readonly any[]>(...values: T): Schema.Enum<T[number]> {\n        return { type: \"enum\", values }\n    }\n\n    /**\n     * The schema for null.\n     * Equivalent to `schemas.enum(null)`.\n     */\n    null: Schema.Enum<null> = { type: \"enum\", values: [null] }\n\n    /**\n     * The schema for any functions.\n     */\n    function(): Schema.Function {\n        return { type: \"function\" }\n    }\n\n    /**\n     * The schema for numbers.\n     * @param options The options.\n     */\n    number({\n        allowInfinity = false,\n        allowNaN = false,\n        intOnly = false,\n        maxValue,\n        minValue,\n    }: Omit<Schema.Number, \"type\"> = {}): Schema.Number {\n        return {\n            type: \"number\",\n            allowInfinity,\n            allowNaN,\n            intOnly,\n            maxValue,\n            minValue,\n        }\n    }\n\n    /**\n     * The schema for 8 bits signed integers.\n     */\n    int8: Schema.Number = {\n        type: \"number\",\n        allowInfinity: false,\n        allowNaN: false,\n        intOnly: true,\n        maxValue: MaxInt8,\n        minValue: MinInt8,\n    }\n\n    /**\n     * The schema for 16 bits signed integers.\n     */\n    int16: Schema.Number = {\n        type: \"number\",\n        allowInfinity: false,\n        allowNaN: false,\n        intOnly: true,\n        maxValue: MaxInt16,\n        minValue: MinInt16,\n    }\n\n    /**\n     * The schema for 32 bits signed integers.\n     */\n    int32: Schema.Number = {\n        type: \"number\",\n        allowInfinity: false,\n        allowNaN: false,\n        intOnly: true,\n        maxValue: MaxInt32,\n        minValue: MinInt32,\n    }\n\n    /**\n     * The schema for 8 bits unsigned integers.\n     */\n    uint8: Schema.Number = {\n        type: \"number\",\n        allowInfinity: false,\n        allowNaN: false,\n        intOnly: true,\n        maxValue: MaxUint8,\n        minValue: 0,\n    }\n\n    /**\n     * The schema for 16 bits unsigned integers.\n     */\n    uint16: Schema.Number = {\n        type: \"number\",\n        allowInfinity: false,\n        allowNaN: false,\n        intOnly: true,\n        maxValue: MaxUint16,\n        minValue: 0,\n    }\n\n    /**\n     * The schema for 32 bits unsigned integers.\n     */\n    uint32: Schema.Number = {\n        type: \"number\",\n        allowInfinity: false,\n        allowNaN: false,\n        intOnly: true,\n        maxValue: MaxUint32,\n        minValue: 0,\n    }\n\n    /**\n     * The schema for any objects.\n     */\n    object(): Schema.Object<{}, never, true>\n\n    /**\n     * The schema for plain objects. All known properties are optional.\n     * @param properties The schema of known properties.\n     */\n    object<TProperties extends Record<string | number, Schema>>(\n        properties: TProperties,\n    ): Schema.Object<TProperties, never, false>\n\n    /**\n     * The schema for plain objects. All known properties are optional.\n     * @param properties The schema of known properties.\n     * @param options The options.\n     */\n    object<TProperties extends Record<string | number, Schema>>(\n        properties: TProperties,\n        options: Record<string | number | symbol, never>,\n    ): Schema.Object<TProperties, never, false>\n\n    /**\n     * The schema for plain objects. All known properties are optional.\n     * @param properties The schema of known properties.\n     * @param options The options.\n     */\n    object<\n        TProperties extends Record<string | number, Schema>,\n        TAllowUnknown extends boolean\n    >(\n        properties: TProperties,\n        options: { allowUnknown: TAllowUnknown },\n    ): Schema.Object<TProperties, never, TAllowUnknown>\n\n    /**\n     * The schema for plain objects. All known properties are required.\n     * @param properties The schema of known properties.\n     * @param options The options.\n     */\n    object<TProperties extends Record<string | number, Schema>>(\n        properties: TProperties,\n        options: { required: true },\n    ): Schema.Object<TProperties, keyof TProperties, false>\n\n    /**\n     * The schema for plain objects. Specified known properties are required.\n     * @param properties The schema of known properties.\n     * @param options The options.\n     */\n    object<\n        TProperties extends Record<string | number, Schema>,\n        TRequired extends keyof TProperties\n    >(\n        properties: TProperties,\n        options: { required: readonly TRequired[] },\n    ): Schema.Object<TProperties, TRequired, false>\n\n    /**\n     * The schema for plain objects. All known properties are required.\n     * @param properties The schema of known properties.\n     * @param options The options.\n     */\n    object<\n        TProperties extends Record<string | number, Schema>,\n        TAllowUnknown extends boolean\n    >(\n        properties: TProperties,\n        options: { allowUnknown: TAllowUnknown; required: true },\n    ): Schema.Object<TProperties, keyof TProperties, TAllowUnknown>\n\n    /**\n     * The schema for plain objects. Specific properties are required.\n     * @param properties The schema of known properties.\n     * @param options The options.\n     */\n    object<\n        TProperties extends Record<string | number, Schema>,\n        TRequired extends keyof TProperties,\n        TAllowUnknown extends boolean\n    >(\n        properties: TProperties,\n        options: {\n            allowUnknown: TAllowUnknown\n            required: readonly TRequired[]\n        },\n    ): Schema.Object<TProperties, TRequired, TAllowUnknown>\n\n    // Implementation\n    object(\n        properties?: Record<string | number, Schema>,\n        {\n            allowUnknown = false,\n            required = [],\n        }: { allowUnknown?: boolean; required?: true | readonly string[] } = {},\n    ): Schema.Object<Record<string | number, Schema>, any, boolean> {\n        if (properties === undefined) {\n            return {\n                type: \"object\",\n                allowUnknown: true,\n                properties: {},\n                required: [],\n            }\n        }\n        return {\n            type: \"object\",\n            allowUnknown,\n            properties,\n            required: required === true ? Object.keys(properties) : required,\n        }\n    }\n\n    /**\n     * The schema for any objects.\n     */\n    record(): Schema.Record<Schema.Any>\n\n    /**\n     * The schema for plain objects.\n     * @param properties The schema of properties.\n     */\n    record<T extends Schema>(properties: T): Schema.Record<T>\n\n    // Implementation\n    record(properties: Schema = { type: \"any\" }): Schema.Record<Schema> {\n        return { type: \"record\", properties }\n    }\n\n    /**\n     * The schema for strings.\n     * @param options The options.\n     */\n    string({\n        maxLength = MaxStringLength,\n        minLength = 0,\n        pattern,\n    }: Omit<Schema.String, \"type\"> = {}): Schema.String {\n        return { type: \"string\", maxLength, minLength, pattern }\n    }\n\n    /**\n     * The schema for any symbols.\n     */\n    symbol(): Schema.Symbol {\n        return { type: \"symbol\" }\n    }\n\n    /**\n     * The schema for tuples.\n     * @param elements The schema of elements.\n     */\n    tuple<T extends readonly Schema[]>(...elements: T): Schema.Tuple<T> {\n        return { type: \"tuple\", elements }\n    }\n\n    /**\n     * The schema for any of listed schemas.\n     * @param firstSchema One of allowed schemas.\n     * @param restSchemas Rest of allowed schemas.\n     */\n    anyOf<T extends Schema, U extends readonly Schema[]>(\n        firstSchema: T,\n        ...restSchemas: U\n    ): Schema.Union<T | U[number]>\n\n    // Implementation\n    anyOf<T extends readonly Schema[]>(...schemas: T): Schema.Union<T[number]> {\n        return { type: \"union\", schemas }\n    }\n}\n/* eslint-enable class-methods-use-this */\n\n/**\n * The schema factories.\n */\nexport const schemas = Object.freeze(new SchemaFactories())\n","import { createValidationOfSchema } from \"./builder\"\nimport { DefaultMessage, Message } from \"./message\"\nimport { TypeOf } from \"./real-types\"\nimport { Schema } from \"./schema-types\"\nimport { ValidationError } from \"./validation-error\"\n\n/**\n * Validate a value by a given schema.\n *\n * If the `value` passed the validation, the `value` gets the specific type that\n * is computed from the schema type `T`. Otherwise, the validation function\n * throws a validation error.\n *\n * The validation code is cached for each schema object into a `WeakMap` object.\n * When GC collected the schema object, the validation code of that is abandoned\n * together.\n *\n * The {@link createValidation} function creates the validation function of\n * schemas to validate values efficiently. Consider using that if you planned to\n * validate values many times.\n *\n * @param schema The schema of the validation.\n * @param value The value to validate.\n * @param options Optional. The options.\n * @throws {@link ValidationError} Thrown if the `value` didn't pass the\n * validation.\n */\nexport function validate<T extends Schema>(\n    schema: T,\n    value: any,\n    { messages = DefaultMessage, name = \"value\" }: validate.Options = {},\n): asserts value is TypeOf<T> {\n    const errors = createValidationOfSchema(schema)(name, value)\n    if (errors.length > 0) {\n        throw new ValidationError(messages, name, errors)\n    }\n}\n\nexport namespace validate {\n    /**\n     * The options of validation.\n     */\n    export type Options = {\n        /**\n         * The error message generator.\n         */\n        messages?: Message\n        /**\n         * The name of the target value.\n         * This will be used in error messages.\n         */\n        name?: string\n    }\n}\n"],"names":["valueToString"],"mappings":"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"}